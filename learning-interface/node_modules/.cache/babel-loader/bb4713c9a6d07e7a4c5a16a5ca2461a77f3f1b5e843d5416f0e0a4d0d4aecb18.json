{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { WaveFileReader } from './wavefile-reader';\nimport { writeString } from './parsers/write-string';\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\n\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\nexport class WaveFileParser extends WaveFileReader {\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   */\n  toBuffer() {\n    this.uInt16.be = this.container === 'RIFX';\n    this.uInt32.be = this.uInt16.be;\n    /** @type {!Array<!Array<number>>} */\n    let fileBody = [this.getJunkBytes_(), this.getDs64Bytes_(), this.getBextBytes_(), this.getiXMLBytes_(), this.getFmtBytes_(), this.getFactBytes_(), packString(this.data.chunkId), pack(this.data.samples.length, this.uInt32), this.data.samples, this.getCueBytes_(), this.getSmplBytes_(), this.getLISTBytes_(), this.get_PMXBytes_()];\n    /** @type {number} */\n    let fileBodyLength = 0;\n    for (let i = 0; i < fileBody.length; i++) {\n      fileBodyLength += fileBody[i].length;\n    }\n    /** @type {!Uint8Array} */\n    let file = new Uint8Array(fileBodyLength + 12);\n    /** @type {number} */\n    let index = 0;\n    index = packStringTo(this.container, file, index);\n    index = packTo(fileBodyLength + 4, this.uInt32, file, index);\n    index = packStringTo(this.format, file, index);\n    for (let i = 0; i < fileBody.length; i++) {\n      file.set(fileBody[i], index);\n      index += fileBody[i].length;\n    }\n    return file;\n  }\n\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @private\r\n   */\n  getBextBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    this.enforceBext_();\n    if (this.bext.chunkId) {\n      this.bext.chunkSize = 602 + this.bext.codingHistory.length;\n      bytes = bytes.concat(packString(this.bext.chunkId), pack(602 + this.bext.codingHistory.length, this.uInt32), writeString(this.bext.description, 256), writeString(this.bext.originator, 32), writeString(this.bext.originatorReference, 32), writeString(this.bext.originationDate, 10), writeString(this.bext.originationTime, 8), pack(this.bext.timeReference[0], this.uInt32), pack(this.bext.timeReference[1], this.uInt32), pack(this.bext.version, this.uInt16), writeString(this.bext.UMID, 64), pack(this.bext.loudnessValue, this.uInt16), pack(this.bext.loudnessRange, this.uInt16), pack(this.bext.maxTruePeakLevel, this.uInt16), pack(this.bext.maxMomentaryLoudness, this.uInt16), pack(this.bext.maxShortTermLoudness, this.uInt16), writeString(this.bext.reserved, 180), writeString(this.bext.codingHistory, this.bext.codingHistory.length));\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\n  enforceBext_() {\n    for (let prop in this.bext) {\n      if (this.bext.hasOwnProperty(prop)) {\n        if (this.bext[prop] && prop != 'timeReference') {\n          this.bext.chunkId = 'bext';\n          break;\n        }\n      }\n    }\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\n      this.bext.chunkId = 'bext';\n    }\n  }\n\n  /**\r\n   * Return the bytes of the 'iXML' chunk.\r\n   * @return {!Array<number>} The 'iXML' chunk bytes.\r\n   * @private\r\n   */\n  getiXMLBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this.iXML.chunkId) {\n      /** @type {!Array<number>} */\n      let iXMLPackedValue = packString(this.iXML.value);\n      this.iXML.chunkSize = iXMLPackedValue.length;\n      bytes = bytes.concat(packString(this.iXML.chunkId), pack(this.iXML.chunkSize, this.uInt32), iXMLPackedValue);\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\n  getDs64Bytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this.ds64.chunkId) {\n      bytes = bytes.concat(packString(this.ds64.chunkId), pack(this.ds64.chunkSize, this.uInt32), pack(this.ds64.riffSizeHigh, this.uInt32), pack(this.ds64.riffSizeLow, this.uInt32), pack(this.ds64.dataSizeHigh, this.uInt32), pack(this.ds64.dataSizeLow, this.uInt32), pack(this.ds64.originationTime, this.uInt32), pack(this.ds64.sampleCountHigh, this.uInt32), pack(this.ds64.sampleCountLow, this.uInt32));\n    }\n    //if (this.ds64.tableLength) {\n    //  ds64Bytes = ds64Bytes.concat(\n    //    pack(this.ds64.tableLength, this.uInt32),\n    //    this.ds64.table);\n    //}\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\n  getCueBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this.cue.chunkId) {\n      /** @type {!Array<number>} */\n      let cuePointsBytes = this.getCuePointsBytes_();\n      bytes = bytes.concat(packString(this.cue.chunkId), pack(cuePointsBytes.length + 4, this.uInt32),\n      // chunkSize\n      pack(this.cue.dwCuePoints, this.uInt32), cuePointsBytes);\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\n  getCuePointsBytes_() {\n    /** @type {!Array<number>} */\n    let points = [];\n    for (let i = 0; i < this.cue.dwCuePoints; i++) {\n      points = points.concat(pack(this.cue.points[i].dwName, this.uInt32), pack(this.cue.points[i].dwPosition, this.uInt32), packString(this.cue.points[i].fccChunk), pack(this.cue.points[i].dwChunkStart, this.uInt32), pack(this.cue.points[i].dwBlockStart, this.uInt32), pack(this.cue.points[i].dwSampleOffset, this.uInt32));\n    }\n    return points;\n  }\n\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\n  getSmplBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this.smpl.chunkId) {\n      /** @type {!Array<number>} */\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\n      bytes = bytes.concat(packString(this.smpl.chunkId), pack(smplLoopsBytes.length + 36, this.uInt32),\n      //chunkSize\n      pack(this.smpl.dwManufacturer, this.uInt32), pack(this.smpl.dwProduct, this.uInt32), pack(this.smpl.dwSamplePeriod, this.uInt32), pack(this.smpl.dwMIDIUnityNote, this.uInt32), pack(this.smpl.dwMIDIPitchFraction, this.uInt32), pack(this.smpl.dwSMPTEFormat, this.uInt32), pack(this.smpl.dwSMPTEOffset, this.uInt32), pack(this.smpl.dwNumSampleLoops, this.uInt32), pack(this.smpl.dwSamplerData, this.uInt32), smplLoopsBytes);\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\n  getSmplLoopsBytes_() {\n    /** @type {!Array<number>} */\n    let loops = [];\n    for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\n      loops = loops.concat(pack(this.smpl.loops[i].dwName, this.uInt32), pack(this.smpl.loops[i].dwType, this.uInt32), pack(this.smpl.loops[i].dwStart, this.uInt32), pack(this.smpl.loops[i].dwEnd, this.uInt32), pack(this.smpl.loops[i].dwFraction, this.uInt32), pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\n    }\n    return loops;\n  }\n\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\n  getFactBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this.fact.chunkId) {\n      bytes = bytes.concat(packString(this.fact.chunkId), pack(this.fact.chunkSize, this.uInt32), pack(this.fact.dwSampleLength, this.uInt32));\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\n  getFmtBytes_() {\n    /** @type {!Array<number>} */\n    let fmtBytes = [];\n    if (this.fmt.chunkId) {\n      /** @type {!Array<number>} */\n      let bytes = fmtBytes.concat(packString(this.fmt.chunkId), pack(this.fmt.chunkSize, this.uInt32), pack(this.fmt.audioFormat, this.uInt16), pack(this.fmt.numChannels, this.uInt16), pack(this.fmt.sampleRate, this.uInt32), pack(this.fmt.byteRate, this.uInt32), pack(this.fmt.blockAlign, this.uInt16), pack(this.fmt.bitsPerSample, this.uInt16), this.getFmtExtensionBytes_());\n      this.enforceByteLen_(bytes);\n      return bytes;\n    }\n    throw Error('Could not find the \"fmt \" chunk');\n  }\n\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\n  getFmtExtensionBytes_() {\n    /** @type {!Array<number>} */\n    let extension = [];\n    if (this.fmt.chunkSize > 16) {\n      extension = extension.concat(pack(this.fmt.cbSize, this.uInt16));\n    }\n    if (this.fmt.chunkSize > 18) {\n      extension = extension.concat(pack(this.fmt.validBitsPerSample, this.uInt16));\n    }\n    if (this.fmt.chunkSize > 20) {\n      extension = extension.concat(pack(this.fmt.dwChannelMask, this.uInt32));\n    }\n    if (this.fmt.chunkSize > 24) {\n      extension = extension.concat(pack(this.fmt.subformat[0], this.uInt32), pack(this.fmt.subformat[1], this.uInt32), pack(this.fmt.subformat[2], this.uInt32), pack(this.fmt.subformat[3], this.uInt32));\n    }\n    return extension;\n  }\n\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @private\r\n   */\n  getLISTBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    for (let i = 0; i < this.LIST.length; i++) {\n      /** @type {!Array<number>} */\n      let subChunksBytes = this.getLISTSubChunksBytes_(this.LIST[i].subChunks, this.LIST[i].format);\n      bytes = bytes.concat(packString(this.LIST[i].chunkId), pack(subChunksBytes.length + 4, this.uInt32),\n      //chunkSize\n      packString(this.LIST[i].format), subChunksBytes);\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\n  getLISTSubChunksBytes_(subChunks, format) {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    for (let i = 0, len = subChunks.length; i < len; i++) {\n      if (format == 'INFO') {\n        bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\n      } else if (format == 'adtl') {\n        bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\n      }\n      this.enforceByteLen_(bytes);\n    }\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\n  getLISTINFOSubChunksBytes_(subChunk) {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    /** @type {!Array<number>} */\n    let LISTsubChunkValue = writeString(subChunk.value, subChunk.value.length);\n    bytes = bytes.concat(packString(subChunk.chunkId), pack(LISTsubChunkValue.length + 1, this.uInt32),\n    //chunkSize\n    LISTsubChunkValue);\n    bytes.push(0);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\n  getLISTadtlSubChunksBytes_(subChunk) {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\n      /** @type {!Array<number>} */\n      let LISTsubChunkValue = writeString(subChunk.value, subChunk.value.length);\n      bytes = bytes.concat(packString(subChunk.chunkId), pack(LISTsubChunkValue.length + 4 + 1, this.uInt32),\n      //chunkSize\n      pack(subChunk.dwName, this.uInt32), LISTsubChunkValue);\n      bytes.push(0);\n    } else if (subChunk.chunkId == 'ltxt') {\n      bytes = bytes.concat(this.getLtxtChunkBytes_(subChunk));\n    }\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\n  getLtxtChunkBytes_(ltxt) {\n    return [].concat(packString(ltxt.chunkId), pack(ltxt.value.length + 20, this.uInt32), pack(ltxt.dwName, this.uInt32), pack(ltxt.dwSampleLength, this.uInt32), pack(ltxt.dwPurposeID, this.uInt32), pack(ltxt.dwCountry, this.uInt16), pack(ltxt.dwLanguage, this.uInt16), pack(ltxt.dwDialect, this.uInt16), pack(ltxt.dwCodePage, this.uInt16),\n    // should always be a empty string;\n    // kept for compatibility\n    writeString(ltxt.value, ltxt.value.length));\n  }\n\n  /**\r\n   * Return the bytes of the '_PMX' chunk.\r\n   * @return {!Array<number>} The '_PMX' chunk bytes.\r\n   * @private\r\n   */\n  get_PMXBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this._PMX.chunkId) {\n      /** @type {!Array<number>} */\n      let _PMXPackedValue = packString(this._PMX.value);\n      this._PMX.chunkSize = _PMXPackedValue.length;\n      bytes = bytes.concat(packString(this._PMX.chunkId), pack(this._PMX.chunkSize, this.uInt32), _PMXPackedValue);\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @private\r\n   */\n  getJunkBytes_() {\n    /** @type {!Array<number>} */\n    let bytes = [];\n    if (this.junk.chunkId) {\n      return bytes.concat(packString(this.junk.chunkId), pack(this.junk.chunkData.length, this.uInt32),\n      //chunkSize\n      this.junk.chunkData);\n    }\n    this.enforceByteLen_(bytes);\n    return bytes;\n  }\n\n  /**\r\n   * Push a null byte into a byte array if\r\n   * the byte count is odd.\r\n   * @param {!Array<number>} bytes The byte array.\r\n   * @private\r\n   */\n  enforceByteLen_(bytes) {\n    if (bytes.length % 2) {\n      bytes.push(0);\n    }\n  }\n}","map":{"version":3,"names":["WaveFileReader","writeString","packTo","packStringTo","packString","pack","WaveFileParser","toBuffer","uInt16","be","container","uInt32","fileBody","getJunkBytes_","getDs64Bytes_","getBextBytes_","getiXMLBytes_","getFmtBytes_","getFactBytes_","data","chunkId","samples","length","getCueBytes_","getSmplBytes_","getLISTBytes_","get_PMXBytes_","fileBodyLength","i","file","Uint8Array","index","format","set","bytes","enforceBext_","bext","chunkSize","codingHistory","concat","description","originator","originatorReference","originationDate","originationTime","timeReference","version","UMID","loudnessValue","loudnessRange","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","reserved","enforceByteLen_","prop","hasOwnProperty","iXML","iXMLPackedValue","value","ds64","riffSizeHigh","riffSizeLow","dataSizeHigh","dataSizeLow","sampleCountHigh","sampleCountLow","cue","cuePointsBytes","getCuePointsBytes_","dwCuePoints","points","dwName","dwPosition","fccChunk","dwChunkStart","dwBlockStart","dwSampleOffset","smpl","smplLoopsBytes","getSmplLoopsBytes_","dwManufacturer","dwProduct","dwSamplePeriod","dwMIDIUnityNote","dwMIDIPitchFraction","dwSMPTEFormat","dwSMPTEOffset","dwNumSampleLoops","dwSamplerData","loops","dwType","dwStart","dwEnd","dwFraction","dwPlayCount","fact","dwSampleLength","fmtBytes","fmt","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","getFmtExtensionBytes_","Error","extension","cbSize","validBitsPerSample","dwChannelMask","subformat","LIST","subChunksBytes","getLISTSubChunksBytes_","subChunks","len","getLISTINFOSubChunksBytes_","getLISTadtlSubChunksBytes_","subChunk","LISTsubChunkValue","push","indexOf","getLtxtChunkBytes_","ltxt","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","_PMX","_PMXPackedValue","junk","chunkData"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/wavefile-parser.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileParser class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileReader } from './wavefile-reader';\r\nimport { writeString } from './parsers/write-string';\r\nimport { packTo, packStringTo, packString, pack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read and write wav files.\r\n * @extends WaveFileReader\r\n */\r\nexport class WaveFileParser extends WaveFileReader {\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   */\r\n  toBuffer() {\r\n    this.uInt16.be = this.container === 'RIFX';\r\n    this.uInt32.be = this.uInt16.be;\r\n    /** @type {!Array<!Array<number>>} */\r\n    let fileBody = [\r\n      this.getJunkBytes_(),\r\n      this.getDs64Bytes_(),\r\n      this.getBextBytes_(),\r\n      this.getiXMLBytes_(),\r\n      this.getFmtBytes_(),\r\n      this.getFactBytes_(),\r\n      packString(this.data.chunkId),\r\n      pack(this.data.samples.length, this.uInt32),\r\n      this.data.samples,\r\n      this.getCueBytes_(),\r\n      this.getSmplBytes_(),\r\n      this.getLISTBytes_(),\r\n      this.get_PMXBytes_()\r\n    ];\r\n    /** @type {number} */\r\n    let fileBodyLength = 0;\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      fileBodyLength += fileBody[i].length;\r\n    }\r\n    /** @type {!Uint8Array} */\r\n    let file = new Uint8Array(fileBodyLength + 12);\r\n    /** @type {number} */\r\n    let index = 0;\r\n    index = packStringTo(this.container, file, index);\r\n    index = packTo(fileBodyLength + 4, this.uInt32, file, index);\r\n    index = packStringTo(this.format, file, index);\r\n    for (let i=0; i<fileBody.length; i++) {\r\n      file.set(fileBody[i], index);\r\n      index += fileBody[i].length;\r\n    }\r\n    return file;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'bext' chunk.\r\n   * @private\r\n   */\r\n  getBextBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    this.enforceBext_();\r\n    if (this.bext.chunkId) {\r\n      this.bext.chunkSize = 602 + this.bext.codingHistory.length;\r\n      bytes = bytes.concat(\r\n        packString(this.bext.chunkId),\r\n        pack(602 + this.bext.codingHistory.length, this.uInt32),\r\n        writeString(this.bext.description, 256),\r\n        writeString(this.bext.originator, 32),\r\n        writeString(this.bext.originatorReference, 32),\r\n        writeString(this.bext.originationDate, 10),\r\n        writeString(this.bext.originationTime, 8),\r\n        pack(this.bext.timeReference[0], this.uInt32),\r\n        pack(this.bext.timeReference[1], this.uInt32),\r\n        pack(this.bext.version, this.uInt16),\r\n        writeString(this.bext.UMID, 64),\r\n        pack(this.bext.loudnessValue, this.uInt16),\r\n        pack(this.bext.loudnessRange, this.uInt16),\r\n        pack(this.bext.maxTruePeakLevel, this.uInt16),\r\n        pack(this.bext.maxMomentaryLoudness, this.uInt16),\r\n        pack(this.bext.maxShortTermLoudness, this.uInt16),\r\n        writeString(this.bext.reserved, 180),\r\n        writeString(\r\n          this.bext.codingHistory, this.bext.codingHistory.length));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Make sure a 'bext' chunk is created if BWF data was created in a file.\r\n   * @private\r\n   */\r\n  enforceBext_() {\r\n    for (let prop in this.bext) {\r\n      if (this.bext.hasOwnProperty(prop)) {\r\n        if (this.bext[prop] && prop != 'timeReference') {\r\n          this.bext.chunkId = 'bext';\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    if (this.bext.timeReference[0] || this.bext.timeReference[1]) {\r\n      this.bext.chunkId = 'bext';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'iXML' chunk.\r\n   * @return {!Array<number>} The 'iXML' chunk bytes.\r\n   * @private\r\n   */\r\n  getiXMLBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.iXML.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let iXMLPackedValue = packString(this.iXML.value);\r\n      this.iXML.chunkSize = iXMLPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this.iXML.chunkId),\r\n        pack(this.iXML.chunkSize, this.uInt32),\r\n        iXMLPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'ds64' chunk.\r\n   * @return {!Array<number>} The 'ds64' chunk bytes.\r\n   * @private\r\n   */\r\n  getDs64Bytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.ds64.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.ds64.chunkId),\r\n        pack(this.ds64.chunkSize, this.uInt32),\r\n        pack(this.ds64.riffSizeHigh, this.uInt32),\r\n        pack(this.ds64.riffSizeLow, this.uInt32),\r\n        pack(this.ds64.dataSizeHigh, this.uInt32),\r\n        pack(this.ds64.dataSizeLow, this.uInt32),\r\n        pack(this.ds64.originationTime, this.uInt32),\r\n        pack(this.ds64.sampleCountHigh, this.uInt32),\r\n        pack(this.ds64.sampleCountLow, this.uInt32));\r\n    }\r\n    //if (this.ds64.tableLength) {\r\n    //  ds64Bytes = ds64Bytes.concat(\r\n    //    pack(this.ds64.tableLength, this.uInt32),\r\n    //    this.ds64.table);\r\n    //}\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' chunk.\r\n   * @return {!Array<number>} The 'cue ' chunk bytes.\r\n   * @private\r\n   */\r\n  getCueBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.cue.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let cuePointsBytes = this.getCuePointsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.cue.chunkId),\r\n        pack(cuePointsBytes.length + 4, this.uInt32), // chunkSize\r\n        pack(this.cue.dwCuePoints, this.uInt32),\r\n        cuePointsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'cue ' points.\r\n   * @return {!Array<number>} The 'cue ' points as an array of bytes.\r\n   * @private\r\n   */\r\n  getCuePointsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let points = [];\r\n    for (let i=0; i<this.cue.dwCuePoints; i++) {\r\n      points = points.concat(\r\n        pack(this.cue.points[i].dwName, this.uInt32),\r\n        pack(this.cue.points[i].dwPosition, this.uInt32),\r\n        packString(this.cue.points[i].fccChunk),\r\n        pack(this.cue.points[i].dwChunkStart, this.uInt32),\r\n        pack(this.cue.points[i].dwBlockStart, this.uInt32),\r\n        pack(this.cue.points[i].dwSampleOffset, this.uInt32));\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' chunk.\r\n   * @return {!Array<number>} The 'smpl' chunk bytes.\r\n   * @private\r\n   */\r\n  getSmplBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.smpl.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let smplLoopsBytes = this.getSmplLoopsBytes_();\r\n      bytes = bytes.concat(\r\n        packString(this.smpl.chunkId),\r\n        pack(smplLoopsBytes.length + 36, this.uInt32), //chunkSize\r\n        pack(this.smpl.dwManufacturer, this.uInt32),\r\n        pack(this.smpl.dwProduct, this.uInt32),\r\n        pack(this.smpl.dwSamplePeriod, this.uInt32),\r\n        pack(this.smpl.dwMIDIUnityNote, this.uInt32),\r\n        pack(this.smpl.dwMIDIPitchFraction, this.uInt32),\r\n        pack(this.smpl.dwSMPTEFormat, this.uInt32),\r\n        pack(this.smpl.dwSMPTEOffset, this.uInt32),\r\n        pack(this.smpl.dwNumSampleLoops, this.uInt32),\r\n        pack(this.smpl.dwSamplerData, this.uInt32),\r\n        smplLoopsBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'smpl' loops.\r\n   * @return {!Array<number>} The 'smpl' loops as an array of bytes.\r\n   * @private\r\n   */\r\n  getSmplLoopsBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let loops = [];\r\n    for (let i=0; i<this.smpl.dwNumSampleLoops; i++) {\r\n      loops = loops.concat(\r\n        pack(this.smpl.loops[i].dwName, this.uInt32),\r\n        pack(this.smpl.loops[i].dwType, this.uInt32),\r\n        pack(this.smpl.loops[i].dwStart, this.uInt32),\r\n        pack(this.smpl.loops[i].dwEnd, this.uInt32),\r\n        pack(this.smpl.loops[i].dwFraction, this.uInt32),\r\n        pack(this.smpl.loops[i].dwPlayCount, this.uInt32));\r\n    }\r\n    return loops;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fact' chunk.\r\n   * @return {!Array<number>} The 'fact' chunk bytes.\r\n   * @private\r\n   */\r\n  getFactBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.fact.chunkId) {\r\n      bytes = bytes.concat(\r\n        packString(this.fact.chunkId),\r\n        pack(this.fact.chunkSize, this.uInt32),\r\n        pack(this.fact.dwSampleLength, this.uInt32));\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'fmt ' chunk.\r\n   * @return {!Array<number>} The 'fmt' chunk bytes.\r\n   * @throws {Error} if no 'fmt ' chunk is present.\r\n   * @private\r\n   */\r\n  getFmtBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let fmtBytes = [];\r\n    if (this.fmt.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let bytes  = fmtBytes.concat(\r\n        packString(this.fmt.chunkId),\r\n        pack(this.fmt.chunkSize, this.uInt32),\r\n        pack(this.fmt.audioFormat, this.uInt16),\r\n        pack(this.fmt.numChannels, this.uInt16),\r\n        pack(this.fmt.sampleRate, this.uInt32),\r\n        pack(this.fmt.byteRate, this.uInt32),\r\n        pack(this.fmt.blockAlign, this.uInt16),\r\n        pack(this.fmt.bitsPerSample, this.uInt16),\r\n        this.getFmtExtensionBytes_());\r\n      this.enforceByteLen_(bytes);\r\n      return bytes;\r\n    }\r\n    throw Error('Could not find the \"fmt \" chunk');\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the fmt extension fields.\r\n   * @return {!Array<number>} The fmt extension bytes.\r\n   * @private\r\n   */\r\n  getFmtExtensionBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let extension = [];\r\n    if (this.fmt.chunkSize > 16) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.cbSize, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 18) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.validBitsPerSample, this.uInt16));\r\n    }\r\n    if (this.fmt.chunkSize > 20) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.dwChannelMask, this.uInt32));\r\n    }\r\n    if (this.fmt.chunkSize > 24) {\r\n      extension = extension.concat(\r\n        pack(this.fmt.subformat[0], this.uInt32),\r\n        pack(this.fmt.subformat[1], this.uInt32),\r\n        pack(this.fmt.subformat[2], this.uInt32),\r\n        pack(this.fmt.subformat[3], this.uInt32));\r\n    }\r\n    return extension;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'LIST' chunk.\r\n   * @return {!Array<number>} The 'LIST' chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i=0; i<this.LIST.length; i++) {\r\n      /** @type {!Array<number>} */\r\n      let subChunksBytes = this.getLISTSubChunksBytes_(\r\n          this.LIST[i].subChunks, this.LIST[i].format);\r\n      bytes = bytes.concat(\r\n        packString(this.LIST[i].chunkId),\r\n        pack(subChunksBytes.length + 4, this.uInt32), //chunkSize\r\n        packString(this.LIST[i].format),\r\n        subChunksBytes);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk.\r\n   * @param {!Array<!Object>} subChunks The 'LIST' sub chunks.\r\n   * @param {string} format The format of the 'LIST' chunk.\r\n   *    Currently supported values are 'adtl' or 'INFO'.\r\n   * @return {!Array<number>} The sub chunk bytes.\r\n   * @private\r\n   */\r\n  getLISTSubChunksBytes_(subChunks, format) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    for (let i = 0, len = subChunks.length; i < len; i++) {\r\n      if (format == 'INFO') {\r\n        bytes = bytes.concat(this.getLISTINFOSubChunksBytes_(subChunks[i]));\r\n      } else if (format == 'adtl') {\r\n        bytes = bytes.concat(this.getLISTadtlSubChunksBytes_(subChunks[i]));\r\n      }\r\n      this.enforceByteLen_(bytes);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTINFOSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    /** @type {!Array<number>} */\r\n    let LISTsubChunkValue = writeString(\r\n        subChunk.value, subChunk.value.length);\r\n    bytes = bytes.concat(\r\n      packString(subChunk.chunkId),\r\n      pack(LISTsubChunkValue.length + 1, this.uInt32), //chunkSize\r\n      LISTsubChunkValue);\r\n    bytes.push(0);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Object} subChunk The 'LIST' sub chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLISTadtlSubChunksBytes_(subChunk) {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (['labl', 'note'].indexOf(subChunk.chunkId) > -1) {\r\n      /** @type {!Array<number>} */\r\n      let LISTsubChunkValue = writeString(\r\n          subChunk.value,\r\n          subChunk.value.length);\r\n      bytes = bytes.concat(\r\n        packString(subChunk.chunkId),\r\n        pack(LISTsubChunkValue.length + 4 + 1, this.uInt32), //chunkSize\r\n        pack(subChunk.dwName, this.uInt32),\r\n        LISTsubChunkValue);\r\n      bytes.push(0);\r\n    } else if (subChunk.chunkId == 'ltxt') {\r\n      bytes = bytes.concat(\r\n        this.getLtxtChunkBytes_(subChunk));\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of a 'ltxt' chunk.\r\n   * @param {!Object} ltxt the 'ltxt' chunk.\r\n   * @return {!Array<number>}\r\n   * @private\r\n   */\r\n  getLtxtChunkBytes_(ltxt) {\r\n    return [].concat(\r\n      packString(ltxt.chunkId),\r\n      pack(ltxt.value.length + 20, this.uInt32),\r\n      pack(ltxt.dwName, this.uInt32),\r\n      pack(ltxt.dwSampleLength, this.uInt32),\r\n      pack(ltxt.dwPurposeID, this.uInt32),\r\n      pack(ltxt.dwCountry, this.uInt16),\r\n      pack(ltxt.dwLanguage, this.uInt16),\r\n      pack(ltxt.dwDialect, this.uInt16),\r\n      pack(ltxt.dwCodePage, this.uInt16),\r\n       // should always be a empty string;\r\n       // kept for compatibility\r\n      writeString(ltxt.value, ltxt.value.length));\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the '_PMX' chunk.\r\n   * @return {!Array<number>} The '_PMX' chunk bytes.\r\n   * @private\r\n   */\r\n  get_PMXBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this._PMX.chunkId) {\r\n      /** @type {!Array<number>} */\r\n      let _PMXPackedValue = packString(this._PMX.value);\r\n      this._PMX.chunkSize = _PMXPackedValue.length;\r\n      bytes = bytes.concat(\r\n        packString(this._PMX.chunkId),\r\n        pack(this._PMX.chunkSize, this.uInt32),\r\n        _PMXPackedValue);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Return the bytes of the 'junk' chunk.\r\n   * @private\r\n   */\r\n  getJunkBytes_() {\r\n    /** @type {!Array<number>} */\r\n    let bytes = [];\r\n    if (this.junk.chunkId) {\r\n      return bytes.concat(\r\n        packString(this.junk.chunkId),\r\n        pack(this.junk.chunkData.length, this.uInt32), //chunkSize\r\n        this.junk.chunkData);\r\n    }\r\n    this.enforceByteLen_(bytes);\r\n    return bytes;\r\n  }\r\n\r\n  /**\r\n   * Push a null byte into a byte array if\r\n   * the byte count is odd.\r\n   * @param {!Array<number>} bytes The byte array.\r\n   * @private\r\n   */\r\n  enforceByteLen_(bytes) {\r\n    if (bytes.length % 2) {\r\n      bytes.push(0);\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}