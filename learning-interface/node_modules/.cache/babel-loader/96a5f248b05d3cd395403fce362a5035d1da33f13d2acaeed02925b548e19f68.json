{"ast":null,"code":"/*\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode UTF8 strings to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n */\n\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://stackoverflow.com/a/34926911\r\n * @param {!Uint8Array|!Array<number>} buffer A byte buffer.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=0] The buffer index to stop reading.\r\n *   Assumes the buffer length if undefined.\r\n * @return {string}\r\n */\nexport function unpack(buffer, start = 0, end = buffer.length) {\n  /** @type {string} */\n  let str = '';\n  for (let index = start; index < end;) {\n    /** @type {number} */\n    let lowerBoundary = 0x80;\n    /** @type {number} */\n    let upperBoundary = 0xBF;\n    /** @type {boolean} */\n    let replace = false;\n    /** @type {number} */\n    let charCode = buffer[index++];\n    if (charCode >= 0x00 && charCode <= 0x7F) {\n      str += String.fromCharCode(charCode);\n    } else {\n      /** @type {number} */\n      let count = 0;\n      if (charCode >= 0xC2 && charCode <= 0xDF) {\n        count = 1;\n      } else if (charCode >= 0xE0 && charCode <= 0xEF) {\n        count = 2;\n        if (buffer[index] === 0xE0) {\n          lowerBoundary = 0xA0;\n        }\n        if (buffer[index] === 0xED) {\n          upperBoundary = 0x9F;\n        }\n      } else if (charCode >= 0xF0 && charCode <= 0xF4) {\n        count = 3;\n        if (buffer[index] === 0xF0) {\n          lowerBoundary = 0x90;\n        }\n        if (buffer[index] === 0xF4) {\n          upperBoundary = 0x8F;\n        }\n      } else {\n        replace = true;\n      }\n      charCode = charCode & (1 << 8 - count - 1) - 1;\n      for (let i = 0; i < count; i++) {\n        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {\n          replace = true;\n        }\n        charCode = charCode << 6 | buffer[index] & 0x3f;\n        index++;\n      }\n      if (replace) {\n        str += String.fromCharCode(0xFFFD);\n      } else if (charCode <= 0xffff) {\n        str += String.fromCharCode(charCode);\n      } else {\n        charCode -= 0x10000;\n        str += String.fromCharCode((charCode >> 10 & 0x3ff) + 0xd800, (charCode & 0x3ff) + 0xdc00);\n      }\n    }\n  }\n  return str;\n}\n\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n * @param {string} str The string to pack.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to pack the string to.\r\n * @param {number=} index The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\nexport function pack(str, buffer, index = 0) {\n  /** @type {number} */\n  let i = 0;\n  /** @type {number} */\n  let len = str.length;\n  while (i < len) {\n    /** @type {number} */\n    let codePoint = str.codePointAt(i);\n    if (codePoint < 128) {\n      buffer[index] = codePoint;\n      index++;\n    } else {\n      /** @type {number} */\n      let count = 0;\n      /** @type {number} */\n      let offset = 0;\n      if (codePoint <= 0x07FF) {\n        count = 1;\n        offset = 0xC0;\n      } else if (codePoint <= 0xFFFF) {\n        count = 2;\n        offset = 0xE0;\n      } else if (codePoint <= 0x10FFFF) {\n        count = 3;\n        offset = 0xF0;\n        i++;\n      }\n      buffer[index] = (codePoint >> 6 * count) + offset;\n      index++;\n      while (count > 0) {\n        buffer[index] = 0x80 | codePoint >> 6 * (count - 1) & 0x3F;\n        index++;\n        count--;\n      }\n    }\n    i++;\n  }\n  return index;\n}","map":{"version":3,"names":["unpack","buffer","start","end","length","str","index","lowerBoundary","upperBoundary","replace","charCode","String","fromCharCode","count","i","pack","len","codePoint","codePointAt","offset"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/parsers/binary/lib/utf8-parser.js"],"sourcesContent":["/*\r\n * Copyright (c) 2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode UTF8 strings to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n */\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * Invalid characters are replaced with 'REPLACEMENT CHARACTER' (U+FFFD).\r\n * @see https://encoding.spec.whatwg.org/#the-encoding\r\n * @see https://stackoverflow.com/a/34926911\r\n * @param {!Uint8Array|!Array<number>} buffer A byte buffer.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=0] The buffer index to stop reading.\r\n *   Assumes the buffer length if undefined.\r\n * @return {string}\r\n */\r\nexport function unpack(buffer, start=0, end=buffer.length) {\r\n  /** @type {string} */\r\n  let str = '';\r\n  for(let index = start; index < end;) {\r\n    /** @type {number} */\r\n    let lowerBoundary = 0x80;\r\n    /** @type {number} */\r\n    let upperBoundary = 0xBF;\r\n    /** @type {boolean} */\r\n    let replace = false;\r\n    /** @type {number} */\r\n    let charCode = buffer[index++];\r\n    if (charCode >= 0x00 && charCode <= 0x7F) {\r\n      str += String.fromCharCode(charCode);\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      if (charCode >= 0xC2 && charCode <= 0xDF) {\r\n        count = 1;\r\n      } else if (charCode >= 0xE0 && charCode <= 0xEF ) {\r\n        count = 2;\r\n        if (buffer[index] === 0xE0) {\r\n          lowerBoundary = 0xA0;\r\n        }\r\n        if (buffer[index] === 0xED) {\r\n          upperBoundary = 0x9F;\r\n        }\r\n      } else if (charCode >= 0xF0 && charCode <= 0xF4 ) {\r\n        count = 3;\r\n        if (buffer[index] === 0xF0) {\r\n          lowerBoundary = 0x90;\r\n        }\r\n        if (buffer[index] === 0xF4) {\r\n          upperBoundary = 0x8F;\r\n        }\r\n      } else {\r\n        replace = true;\r\n      }\r\n      charCode = charCode & (1 << (8 - count - 1)) - 1;\r\n      for (let i = 0; i < count; i++) {\r\n        if (buffer[index] < lowerBoundary || buffer[index] > upperBoundary) {\r\n          replace = true;\r\n        }\r\n        charCode = (charCode << 6) | (buffer[index] & 0x3f);\r\n        index++;\r\n      }\r\n      if (replace) {\r\n        str += String.fromCharCode(0xFFFD);\r\n      } \r\n      else if (charCode <= 0xffff) {\r\n        str += String.fromCharCode(charCode);\r\n      } else {\r\n        charCode -= 0x10000;\r\n        str += String.fromCharCode(\r\n          ((charCode >> 10) & 0x3ff) + 0xd800,\r\n          (charCode & 0x3ff) + 0xdc00);\r\n      }\r\n    }\r\n  }\r\n  return str;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @see https://encoding.spec.whatwg.org/#utf-8-encoder\r\n * @param {string} str The string to pack.\r\n * @param {!Uint8Array|!Array<number>} buffer The buffer to pack the string to.\r\n * @param {number=} index The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nexport function pack(str, buffer, index=0) {\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let len = str.length;\r\n  while (i < len) {\r\n    /** @type {number} */\r\n    let codePoint = str.codePointAt(i);\r\n    if (codePoint < 128) {\r\n      buffer[index] = codePoint;\r\n      index++;\r\n    } else {\r\n      /** @type {number} */\r\n      let count = 0;\r\n      /** @type {number} */\r\n      let offset = 0;\r\n      if (codePoint <= 0x07FF) {\r\n        count = 1;\r\n        offset = 0xC0;\r\n      } else if(codePoint <= 0xFFFF) {\r\n        count = 2;\r\n        offset = 0xE0;\r\n      } else if(codePoint <= 0x10FFFF) {\r\n        count = 3;\r\n        offset = 0xF0;\r\n        i++;\r\n      }\r\n      buffer[index] = (codePoint >> (6 * count)) + offset;\r\n      index++;\r\n      while (count > 0) {\r\n        buffer[index] = 0x80 | (codePoint >> (6 * (count - 1)) & 0x3F);\r\n        index++;\r\n        count--;\r\n      }\r\n    }\r\n    i++;\r\n  }\r\n  return index;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}