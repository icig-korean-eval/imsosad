{"ast":null,"code":"// Audio recording utilities\n\n// Interface for recording state\n\n// Function to request microphone access\nexport const requestMicrophoneAccess = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    return stream;\n  } catch (error) {\n    console.error('Error accessing microphone:', error);\n    throw error;\n  }\n};\n\n// Class to handle audio recording\nexport class AudioRecorder {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioChunks = [];\n    this.stream = null;\n  }\n  // Start recording\n  async startRecording() {\n    try {\n      this.stream = await requestMicrophoneAccess();\n      this.mediaRecorder = new MediaRecorder(this.stream);\n      this.audioChunks = [];\n      this.mediaRecorder.addEventListener('dataavailable', event => {\n        if (event.data.size > 0) {\n          this.audioChunks.push(event.data);\n        }\n      });\n      this.mediaRecorder.start();\n    } catch (error) {\n      console.error('Failed to start recording:', error);\n      throw error;\n    }\n  }\n\n  // Stop recording and return the audio blob\n  stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder) {\n        reject(new Error('No recording in progress'));\n        return;\n      }\n      this.mediaRecorder.addEventListener('stop', () => {\n        const audioBlob = new Blob(this.audioChunks, {\n          type: 'audio/webm'\n        });\n        this.stopStream();\n        resolve(audioBlob);\n      });\n      this.mediaRecorder.stop();\n    });\n  }\n\n  // Stop all tracks in the stream\n  stopStream() {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n    }\n  }\n\n  // Create a URL for the audio blob\n  static createAudioURL(blob) {\n    return URL.createObjectURL(blob);\n  }\n\n  // Clean up URL when no longer needed\n  static revokeAudioURL(url) {\n    URL.revokeObjectURL(url);\n  }\n}\n\n// Function to play audio from a URL\nexport const playAudio = url => {\n  const audio = new Audio(url);\n  audio.play();\n  return audio;\n};","map":{"version":3,"names":["requestMicrophoneAccess","stream","navigator","mediaDevices","getUserMedia","audio","error","console","AudioRecorder","constructor","mediaRecorder","audioChunks","startRecording","MediaRecorder","addEventListener","event","data","size","push","start","stopRecording","Promise","resolve","reject","Error","audioBlob","Blob","type","stopStream","stop","getTracks","forEach","track","createAudioURL","blob","URL","createObjectURL","revokeAudioURL","url","revokeObjectURL","playAudio","Audio","play"],"sources":["/Users/bagjun-won/test-3d/learning-interface/src/utils/audioUtils.ts"],"sourcesContent":["// Audio recording utilities\n\n// Interface for recording state\nexport interface RecordingState {\n  isRecording: boolean;\n  audioURL: string | null;\n}\n\n// Function to request microphone access\nexport const requestMicrophoneAccess = async (): Promise<MediaStream> => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    return stream;\n  } catch (error) {\n    console.error('Error accessing microphone:', error);\n    throw error;\n  }\n};\n\n// Class to handle audio recording\nexport class AudioRecorder {\n  private mediaRecorder: MediaRecorder | null = null;\n  private audioChunks: Blob[] = [];\n  private stream: MediaStream | null = null;\n\n  // Start recording\n  public async startRecording(): Promise<void> {\n    try {\n      this.stream = await requestMicrophoneAccess();\n      this.mediaRecorder = new MediaRecorder(this.stream);\n      this.audioChunks = [];\n\n      this.mediaRecorder.addEventListener('dataavailable', (event) => {\n        if (event.data.size > 0) {\n          this.audioChunks.push(event.data);\n        }\n      });\n\n      this.mediaRecorder.start();\n    } catch (error) {\n      console.error('Failed to start recording:', error);\n      throw error;\n    }\n  }\n\n  // Stop recording and return the audio blob\n  public stopRecording(): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder) {\n        reject(new Error('No recording in progress'));\n        return;\n      }\n\n      this.mediaRecorder.addEventListener('stop', () => {\n        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });\n        this.stopStream();\n        resolve(audioBlob);\n      });\n\n      this.mediaRecorder.stop();\n    });\n  }\n\n  // Stop all tracks in the stream\n  private stopStream(): void {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n    }\n  }\n\n  // Create a URL for the audio blob\n  public static createAudioURL(blob: Blob): string {\n    return URL.createObjectURL(blob);\n  }\n\n  // Clean up URL when no longer needed\n  public static revokeAudioURL(url: string): void {\n    URL.revokeObjectURL(url);\n  }\n}\n\n// Function to play audio from a URL\nexport const playAudio = (url: string): HTMLAudioElement => {\n  const audio = new Audio(url);\n  audio.play();\n  return audio;\n};\n"],"mappings":"AAAA;;AAEA;;AAMA;AACA,OAAO,MAAMA,uBAAuB,GAAG,MAAAA,CAAA,KAAkC;EACvE,IAAI;IACF,MAAMC,MAAM,GAAG,MAAMC,SAAS,CAACC,YAAY,CAACC,YAAY,CAAC;MAAEC,KAAK,EAAE;IAAK,CAAC,CAAC;IACzE,OAAOJ,MAAM;EACf,CAAC,CAAC,OAAOK,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,6BAA6B,EAAEA,KAAK,CAAC;IACnD,MAAMA,KAAK;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAME,aAAa,CAAC;EAAAC,YAAA;IAAA,KACjBC,aAAa,GAAyB,IAAI;IAAA,KAC1CC,WAAW,GAAW,EAAE;IAAA,KACxBV,MAAM,GAAuB,IAAI;EAAA;EAEzC;EACA,MAAaW,cAAcA,CAAA,EAAkB;IAC3C,IAAI;MACF,IAAI,CAACX,MAAM,GAAG,MAAMD,uBAAuB,CAAC,CAAC;MAC7C,IAAI,CAACU,aAAa,GAAG,IAAIG,aAAa,CAAC,IAAI,CAACZ,MAAM,CAAC;MACnD,IAAI,CAACU,WAAW,GAAG,EAAE;MAErB,IAAI,CAACD,aAAa,CAACI,gBAAgB,CAAC,eAAe,EAAGC,KAAK,IAAK;QAC9D,IAAIA,KAAK,CAACC,IAAI,CAACC,IAAI,GAAG,CAAC,EAAE;UACvB,IAAI,CAACN,WAAW,CAACO,IAAI,CAACH,KAAK,CAACC,IAAI,CAAC;QACnC;MACF,CAAC,CAAC;MAEF,IAAI,CAACN,aAAa,CAACS,KAAK,CAAC,CAAC;IAC5B,CAAC,CAAC,OAAOb,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,4BAA4B,EAAEA,KAAK,CAAC;MAClD,MAAMA,KAAK;IACb;EACF;;EAEA;EACOc,aAAaA,CAAA,EAAkB;IACpC,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAI,CAAC,IAAI,CAACb,aAAa,EAAE;QACvBa,MAAM,CAAC,IAAIC,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAC7C;MACF;MAEA,IAAI,CAACd,aAAa,CAACI,gBAAgB,CAAC,MAAM,EAAE,MAAM;QAChD,MAAMW,SAAS,GAAG,IAAIC,IAAI,CAAC,IAAI,CAACf,WAAW,EAAE;UAAEgB,IAAI,EAAE;QAAa,CAAC,CAAC;QACpE,IAAI,CAACC,UAAU,CAAC,CAAC;QACjBN,OAAO,CAACG,SAAS,CAAC;MACpB,CAAC,CAAC;MAEF,IAAI,CAACf,aAAa,CAACmB,IAAI,CAAC,CAAC;IAC3B,CAAC,CAAC;EACJ;;EAEA;EACQD,UAAUA,CAAA,EAAS;IACzB,IAAI,IAAI,CAAC3B,MAAM,EAAE;MACf,IAAI,CAACA,MAAM,CAAC6B,SAAS,CAAC,CAAC,CAACC,OAAO,CAACC,KAAK,IAAIA,KAAK,CAACH,IAAI,CAAC,CAAC,CAAC;MACtD,IAAI,CAAC5B,MAAM,GAAG,IAAI;IACpB;EACF;;EAEA;EACA,OAAcgC,cAAcA,CAACC,IAAU,EAAU;IAC/C,OAAOC,GAAG,CAACC,eAAe,CAACF,IAAI,CAAC;EAClC;;EAEA;EACA,OAAcG,cAAcA,CAACC,GAAW,EAAQ;IAC9CH,GAAG,CAACI,eAAe,CAACD,GAAG,CAAC;EAC1B;AACF;;AAEA;AACA,OAAO,MAAME,SAAS,GAAIF,GAAW,IAAuB;EAC1D,MAAMjC,KAAK,GAAG,IAAIoC,KAAK,CAACH,GAAG,CAAC;EAC5BjC,KAAK,CAACqC,IAAI,CAAC,CAAC;EACZ,OAAOrC,KAAK;AACd,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}