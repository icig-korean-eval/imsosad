{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { changeBitDepth } from './codecs/bitdepth';\nimport * as imaadpcm from './codecs/imaadpcm';\nimport * as alaw from './codecs/alaw';\nimport * as mulaw from './codecs/mulaw';\nimport { unpackArrayTo } from './parsers/binary';\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\nimport { validateSampleRate } from './validators/validate-sample-rate';\nimport { resample } from './resampler';\n\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\nexport class WaveFileConverter extends WaveFileCueEditor {\n  /**\r\n   * Force a file as RIFF.\r\n   */\n  toRIFF() {\n    /** @type {!Float64Array} */\n    let output = new Float64Array(outputSize_(this.data.samples.length, this.dataType.bits / 8));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, this.bitDepth, output, {\n      container: 'RIFF'\n    });\n  }\n\n  /**\r\n   * Force a file as RIFX.\r\n   */\n  toRIFX() {\n    /** @type {!Float64Array} */\n    let output = new Float64Array(outputSize_(this.data.samples.length, this.dataType.bits / 8));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, this.bitDepth, output, {\n      container: 'RIFX'\n    });\n  }\n\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   */\n  toIMAADPCM() {\n    if (this.fmt.sampleRate !== 8000) {\n      throw new Error('Only 8000 Hz files can be compressed as IMA-ADPCM.');\n    } else if (this.fmt.numChannels !== 1) {\n      throw new Error('Only mono files can be compressed as IMA-ADPCM.');\n    } else {\n      this.assure16Bit_();\n      /** @type {!Int16Array} */\n      let output = new Int16Array(outputSize_(this.data.samples.length, 2));\n      unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n      this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '4', imaadpcm.encode(output), {\n        container: this.correctContainer_()\n      });\n    }\n  }\n\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\n  fromIMAADPCM(bitDepthCode = '16') {\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', imaadpcm.decode(this.data.samples, this.fmt.blockAlign), {\n      container: this.correctContainer_()\n    });\n    if (bitDepthCode != '16') {\n      this.toBitDepth(bitDepthCode);\n    }\n  }\n\n  /**\r\n   * Encode a 16-bit wave file as 8-bit A-Law.\r\n   */\n  toALaw() {\n    this.assure16Bit_();\n    /** @type {!Int16Array} */\n    let output = new Int16Array(outputSize_(this.data.samples.length, 2));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '8a', alaw.encode(output), {\n      container: this.correctContainer_()\n    });\n  }\n\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\n  fromALaw(bitDepthCode = '16') {\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', alaw.decode(this.data.samples), {\n      container: this.correctContainer_()\n    });\n    if (bitDepthCode != '16') {\n      this.toBitDepth(bitDepthCode);\n    }\n  }\n\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   */\n  toMuLaw() {\n    this.assure16Bit_();\n    /** @type {!Int16Array} */\n    let output = new Int16Array(outputSize_(this.data.samples.length, 2));\n    unpackArrayTo(this.data.samples, this.dataType, output, 0, this.data.samples.length);\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '8m', mulaw.encode(output), {\n      container: this.correctContainer_()\n    });\n  }\n\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\n  fromMuLaw(bitDepthCode = '16') {\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, '16', mulaw.decode(this.data.samples), {\n      container: this.correctContainer_()\n    });\n    if (bitDepthCode != '16') {\n      this.toBitDepth(bitDepthCode);\n    }\n  }\n\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} newBitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   */\n  toBitDepth(newBitDepth, changeResolution = true) {\n    /** @type {string} */\n    let toBitDepth = newBitDepth;\n    /** @type {string} */\n    let thisBitDepth = this.bitDepth;\n    if (!changeResolution) {\n      if (newBitDepth != '32f') {\n        toBitDepth = this.dataType.bits.toString();\n      }\n      thisBitDepth = '' + this.dataType.bits;\n    }\n    // If the file is compressed, make it\n    // PCM before changing the bit depth\n    this.assureUncompressed_();\n    /**\r\n     * The original samples, interleaved.\r\n     * @type {!(Array|TypedArray)}\r\n     */\n    let samples = this.getSamples(true);\n    /**\r\n     * The container for the new samples.\r\n     * @type {!Float64Array}\r\n     */\n    let newSamples = new Float64Array(samples.length);\n    // Change the bit depth\n    changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth);\n    // Re-create the file\n    this.fromExisting_(this.fmt.numChannels, this.fmt.sampleRate, newBitDepth, newSamples, {\n      container: this.correctContainer_()\n    });\n  }\n\n  /**\r\n   * Convert the sample rate of the file.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @param {Object=} options The extra configuration, if needed.\r\n   */\n  toSampleRate(sampleRate, options) {\n    this.validateResample_(sampleRate);\n    /** @type {!(Array|TypedArray)} */\n    let samples = this.getSamples();\n    /** @type {!(Array|Float64Array)} */\n    let newSamples = [];\n    // Mono files\n    if (samples.constructor === Float64Array) {\n      newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options);\n      // Multi-channel files\n    } else {\n      for (let i = 0; i < samples.length; i++) {\n        newSamples.push(resample(samples[i], this.fmt.sampleRate, sampleRate, options));\n      }\n    }\n    // Recreate the file\n    this.fromExisting_(this.fmt.numChannels, sampleRate, this.bitDepth, newSamples, {\n      'container': this.correctContainer_()\n    });\n  }\n\n  /**\r\n   * Validate the conditions for resampling.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @throws {Error} If the file cant be resampled.\r\n   * @private\r\n   */\n  validateResample_(sampleRate) {\n    if (!validateSampleRate(this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\n      throw new Error('Invalid sample rate.');\n    } else if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1) {\n      throw new Error('wavefile can\\'t change the sample rate of compressed files.');\n    }\n  }\n\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\n  assure16Bit_() {\n    this.assureUncompressed_();\n    if (this.bitDepth != '16') {\n      this.toBitDepth('16');\n    }\n  }\n\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\n  assureUncompressed_() {\n    if (this.bitDepth == '8a') {\n      this.fromALaw();\n    } else if (this.bitDepth == '8m') {\n      this.fromMuLaw();\n    } else if (this.bitDepth == '4') {\n      this.fromIMAADPCM();\n    }\n  }\n\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\n  correctContainer_() {\n    return this.container == 'RF64' ? 'RIFF' : this.container;\n  }\n\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * This method only reset the fmt , fact, ds64 and data chunks.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples\r\n   *    The samples. Must be in the correct range according to the bit depth.\r\n   * @param {Object} options Used to define the container. Uses RIFF by default.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\n  fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\n    /** @type {!Object} */\n    let tmpWav = new WaveFileCueEditor();\n    Object.assign(this.fmt, tmpWav.fmt);\n    Object.assign(this.fact, tmpWav.fact);\n    Object.assign(this.ds64, tmpWav.ds64);\n    Object.assign(this.data, tmpWav.data);\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\n  }\n}\n\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\nfunction outputSize_(byteLen, byteOffset) {\n  /** @type {number} */\n  let outputSize = byteLen / byteOffset;\n  if (outputSize % 2) {\n    outputSize++;\n  }\n  return outputSize;\n}","map":{"version":3,"names":["changeBitDepth","imaadpcm","alaw","mulaw","unpackArrayTo","WaveFileCueEditor","validateSampleRate","resample","WaveFileConverter","toRIFF","output","Float64Array","outputSize_","data","samples","length","dataType","bits","fromExisting_","fmt","numChannels","sampleRate","bitDepth","container","toRIFX","toIMAADPCM","Error","assure16Bit_","Int16Array","encode","correctContainer_","fromIMAADPCM","bitDepthCode","decode","blockAlign","toBitDepth","toALaw","fromALaw","toMuLaw","fromMuLaw","newBitDepth","changeResolution","thisBitDepth","toString","assureUncompressed_","getSamples","newSamples","toSampleRate","options","validateResample_","constructor","i","push","bitsPerSample","indexOf","tmpWav","Object","assign","fact","ds64","newWavFile_","byteLen","byteOffset","outputSize"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/wavefile-converter.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileConverter class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { changeBitDepth } from './codecs/bitdepth';\r\nimport * as imaadpcm from './codecs/imaadpcm';\r\nimport * as alaw from './codecs/alaw';\r\nimport * as mulaw from './codecs/mulaw';\r\nimport { unpackArrayTo } from './parsers/binary';\r\nimport { WaveFileCueEditor } from './wavefile-cue-editor';\r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { resample } from './resampler';\r\n\r\n/**\r\n * A class to convert wav files to other types of wav files.\r\n * @extends WaveFileCueEditor\r\n * @ignore\r\n */\r\nexport class WaveFileConverter extends WaveFileCueEditor {\r\n\r\n  /**\r\n   * Force a file as RIFF.\r\n   */\r\n  toRIFF() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFF'});\r\n  }\r\n\r\n  /**\r\n   * Force a file as RIFX.\r\n   */\r\n  toRIFX() {\r\n    /** @type {!Float64Array} */\r\n    let output = new Float64Array(\r\n      outputSize_(this.data.samples.length, this.dataType.bits / 8));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n      0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      this.bitDepth,\r\n      output,\r\n      {container: 'RIFX'});\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 4-bit IMA ADPCM.\r\n   * @throws {Error} If sample rate is not 8000.\r\n   * @throws {Error} If number of channels is not 1.\r\n   */\r\n  toIMAADPCM() {\r\n    if (this.fmt.sampleRate !== 8000) {\r\n      throw new Error(\r\n        'Only 8000 Hz files can be compressed as IMA-ADPCM.');\r\n    } else if (this.fmt.numChannels !== 1) {\r\n      throw new Error(\r\n        'Only mono files can be compressed as IMA-ADPCM.');\r\n    } else {\r\n      this.assure16Bit_();\r\n      /** @type {!Int16Array} */\r\n      let output = new Int16Array(\r\n        outputSize_(this.data.samples.length, 2));\r\n      unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n      this.fromExisting_(\r\n        this.fmt.numChannels,\r\n        this.fmt.sampleRate,\r\n        '4',\r\n        imaadpcm.encode(output),\r\n        {container: this.correctContainer_()});\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Decode a 4-bit IMA ADPCM wave file as a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromIMAADPCM(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      imaadpcm.decode(this.data.samples, this.fmt.blockAlign),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode a 16-bit wave file as 8-bit A-Law.\r\n   */\r\n  toALaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8a',\r\n      alaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit A-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromALaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      alaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Encode 16-bit wave file as 8-bit mu-Law.\r\n   */\r\n  toMuLaw() {\r\n    this.assure16Bit_();\r\n    /** @type {!Int16Array} */\r\n    let output = new Int16Array(\r\n      outputSize_(this.data.samples.length, 2));\r\n    unpackArrayTo(this.data.samples, this.dataType, output,\r\n        0, this.data.samples.length);\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '8m',\r\n      mulaw.encode(output),\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Decode a 8-bit mu-Law wave file into a 16-bit wave file.\r\n   * @param {string=} [bitDepthCode='16'] The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats).\r\n   */\r\n  fromMuLaw(bitDepthCode='16') {\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      '16',\r\n      mulaw.decode(this.data.samples),\r\n      {container: this.correctContainer_()});\r\n    if (bitDepthCode != '16') {\r\n      this.toBitDepth(bitDepthCode);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Change the bit depth of the samples.\r\n   * @param {string} newBitDepth The new bit depth of the samples.\r\n   *    One of '8' ... '32' (integers), '32f' or '64' (floats)\r\n   * @param {boolean=} [changeResolution=true] A boolean indicating if the\r\n   *    resolution of samples should be actually changed or not.\r\n   * @throws {Error} If the bit depth is not valid.\r\n   */\r\n  toBitDepth(newBitDepth, changeResolution=true) {\r\n    /** @type {string} */\r\n    let toBitDepth = newBitDepth;\r\n    /** @type {string} */\r\n    let thisBitDepth = this.bitDepth;\r\n    if (!changeResolution) {\r\n      if (newBitDepth != '32f') {\r\n        toBitDepth = this.dataType.bits.toString();\r\n      }\r\n      thisBitDepth = '' + this.dataType.bits;\r\n    }\r\n    // If the file is compressed, make it\r\n    // PCM before changing the bit depth\r\n    this.assureUncompressed_();\r\n    /**\r\n     * The original samples, interleaved.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = this.getSamples(true);\r\n    /**\r\n     * The container for the new samples.\r\n     * @type {!Float64Array}\r\n     */\r\n    let newSamples = new Float64Array(samples.length);\r\n    // Change the bit depth\r\n    changeBitDepth(samples, thisBitDepth, newSamples, toBitDepth);\r\n    // Re-create the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels,\r\n      this.fmt.sampleRate,\r\n      newBitDepth,\r\n      newSamples,\r\n      {container: this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Convert the sample rate of the file.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @param {Object=} options The extra configuration, if needed.\r\n   */\r\n  toSampleRate(sampleRate, options) {\r\n    this.validateResample_(sampleRate);\r\n    /** @type {!(Array|TypedArray)} */\r\n    let samples = this.getSamples();\r\n    /** @type {!(Array|Float64Array)} */\r\n    let newSamples = [];\r\n    // Mono files\r\n    if (samples.constructor === Float64Array) {\r\n      newSamples = resample(samples, this.fmt.sampleRate, sampleRate, options);\r\n    // Multi-channel files\r\n    } else {\r\n      for (let i = 0; i < samples.length; i++) {\r\n        newSamples.push(resample(\r\n          samples[i], this.fmt.sampleRate, sampleRate, options));\r\n      }\r\n    }\r\n    // Recreate the file\r\n    this.fromExisting_(\r\n      this.fmt.numChannels, sampleRate, this.bitDepth, newSamples,\r\n      {'container': this.correctContainer_()});\r\n  }\r\n\r\n  /**\r\n   * Validate the conditions for resampling.\r\n   * @param {number} sampleRate The target sample rate.\r\n   * @throws {Error} If the file cant be resampled.\r\n   * @private\r\n   */\r\n  validateResample_(sampleRate) {\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    } else if (['4','8a','8m'].indexOf(this.bitDepth) > -1) {\r\n      throw new Error(\r\n        'wavefile can\\'t change the sample rate of compressed files.');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Make the file 16-bit if it is not.\r\n   * @private\r\n   */\r\n  assure16Bit_() {\r\n    this.assureUncompressed_();\r\n    if (this.bitDepth != '16') {\r\n      this.toBitDepth('16');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Uncompress the samples in case of a compressed file.\r\n   * @private\r\n   */\r\n  assureUncompressed_() {\r\n    if (this.bitDepth == '8a') {\r\n      this.fromALaw();\r\n    } else if (this.bitDepth == '8m') {\r\n      this.fromMuLaw();\r\n    } else if (this.bitDepth == '4') {\r\n      this.fromIMAADPCM();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return 'RIFF' if the container is 'RF64', the current container name\r\n   * otherwise. Used to enforce 'RIFF' when RF64 is not allowed.\r\n   * @return {string}\r\n   * @private\r\n   */\r\n  correctContainer_() {\r\n    return this.container == 'RF64' ? 'RIFF' : this.container;\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * This method only reset the fmt , fact, ds64 and data chunks.\r\n   * @param {number} numChannels The number of channels\r\n   *    (Integer numbers: 1 for mono, 2 stereo and so on).\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integer numbers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples\r\n   *    The samples. Must be in the correct range according to the bit depth.\r\n   * @param {Object} options Used to define the container. Uses RIFF by default.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  fromExisting_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileCueEditor();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n}\r\n\r\n/**\r\n * Return the size in bytes of the output sample array when applying\r\n * compression to 16-bit samples.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction outputSize_(byteLen, byteOffset) {\r\n  /** @type {number} */\r\n  let outputSize = byteLen / byteOffset;\r\n  if (outputSize % 2) {\r\n    outputSize++;\r\n  }\r\n  return outputSize;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}