{"ast":null,"code":"/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2016 acida. MIT License.  \r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview IMA ADPCM codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/imaadpcm\r\n */\n\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\nconst INDEX_TABLE = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\nconst STEP_TABLE = [7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767];\n\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Int16Array} samples A array of samples.\r\n * @return {!Uint8Array}\r\n */\nexport function encode(samples) {\n  /** @type {!Object} */\n  let state = {\n    index: 0,\n    predicted: 0,\n    step: 7\n  };\n  /** @type {!Uint8Array} */\n  let adpcmSamples = new Uint8Array(samples.length);\n  /** @type {!Array<number>} */\n  let block = [];\n  /** @type {number} */\n  let fileIndex = 0;\n  /** @type {number} */\n  let blockCount = 0;\n  for (let i = 0, len = samples.length; i < len; i++) {\n    if (i % 505 == 0 && i != 0) {\n      adpcmSamples.set(encodeBlock(block, state), fileIndex);\n      fileIndex += 256;\n      block = [];\n      blockCount++;\n    }\n    block.push(samples[i]);\n  }\n  let samplesLength = samples.length / 2;\n  if (samplesLength % 2) {\n    samplesLength++;\n  }\n  return adpcmSamples.slice(0, samplesLength + 512 + blockCount * 4);\n}\n\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Int16Array}\r\n */\nexport function decode(adpcmSamples, blockAlign = 256) {\n  /** @type {!Object} */\n  let state = {\n    index: 0,\n    predicted: 0,\n    step: 7\n  };\n  /** @type {!Int16Array} */\n  let samples = new Int16Array(adpcmSamples.length * 2);\n  /** @type {!Array<number>} */\n  let block = [];\n  /** @type {number} */\n  let fileIndex = 0;\n  for (let i = 0, len = adpcmSamples.length; i < len; i++) {\n    if (i % blockAlign == 0 && i != 0) {\n      let decoded = decodeBlock(block, state);\n      samples.set(decoded, fileIndex);\n      fileIndex += decoded.length;\n      block = [];\n    }\n    block.push(adpcmSamples[i]);\n  }\n  return samples;\n}\n\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n */\nfunction encodeBlock(block, state) {\n  /** @type {!Array<number>} */\n  let adpcmSamples = blockHead_(block[0], state);\n  for (let i = 3, len = block.length; i < len; i += 2) {\n    /** @type {number} */\n    let sample2 = encodeSample_(block[i], state);\n    /** @type {number} */\n    let sample = encodeSample_(block[i + 1], state);\n    adpcmSamples.push(sample << 4 | sample2);\n  }\n  return adpcmSamples;\n}\n\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @param {!Object} state The decoder state.\r\n * @return {!Array<number>}\r\n */\nfunction decodeBlock(block, state) {\n  state.predicted = sign_(block[1] << 8 | block[0]);\n  state.index = block[2];\n  state.step = STEP_TABLE[state.index];\n  /** @type {!Array<number>} */\n  let result = [state.predicted, state.predicted];\n  for (let i = 4, len = block.length; i < len; i++) {\n    /** @type {number} */\n    let original_sample = block[i];\n    /** @type {number} */\n    let second_sample = original_sample >> 4;\n    /** @type {number} */\n    let first_sample = second_sample << 4 ^ original_sample;\n    result.push(decodeSample_(first_sample, state));\n    result.push(decodeSample_(second_sample, state));\n  }\n  return result;\n}\n\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\nfunction sign_(num) {\n  return num > 32768 ? num - 65536 : num;\n}\n\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @param {!Object} state The encoder state.\r\n * @return {number}\r\n * @private\r\n */\nfunction encodeSample_(sample, state) {\n  /** @type {number} */\n  let delta = sample - state.predicted;\n  /** @type {number} */\n  let value = 0;\n  if (delta >= 0) {\n    value = 0;\n  } else {\n    value = 8;\n    delta = -delta;\n  }\n  /** @type {number} */\n  let step = STEP_TABLE[state.index];\n  /** @type {number} */\n  let diff = step >> 3;\n  if (delta > step) {\n    value |= 4;\n    delta -= step;\n    diff += step;\n  }\n  step >>= 1;\n  if (delta > step) {\n    value |= 2;\n    delta -= step;\n    diff += step;\n  }\n  step >>= 1;\n  if (delta > step) {\n    value |= 1;\n    diff += step;\n  }\n  updateEncoder_(value, diff, state);\n  return value;\n}\n\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @param {!Object} state The encoder state.\r\n * @private\r\n */\nfunction updateEncoder_(value, diff, state) {\n  if (value & 8) {\n    state.predicted -= diff;\n  } else {\n    state.predicted += diff;\n  }\n  if (state.predicted < -0x8000) {\n    state.predicted = -0x8000;\n  } else if (state.predicted > 0x7fff) {\n    state.predicted = 0x7fff;\n  }\n  state.index += INDEX_TABLE[value & 7];\n  if (state.index < 0) {\n    state.index = 0;\n  } else if (state.index > 88) {\n    state.index = 88;\n  }\n}\n\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @return {number}\r\n * @private\r\n */\nfunction decodeSample_(nibble, state) {\n  /** @type {number} */\n  let difference = 0;\n  if (nibble & 4) {\n    difference += state.step;\n  }\n  if (nibble & 2) {\n    difference += state.step >> 1;\n  }\n  if (nibble & 1) {\n    difference += state.step >> 2;\n  }\n  difference += state.step >> 3;\n  if (nibble & 8) {\n    difference = -difference;\n  }\n  state.predicted += difference;\n  if (state.predicted > 32767) {\n    state.predicted = 32767;\n  } else if (state.predicted < -32767) {\n    state.predicted = -32767;\n  }\n  updateDecoder_(nibble, state);\n  return state.predicted;\n}\n\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @private\r\n */\nfunction updateDecoder_(nibble, state) {\n  state.index += INDEX_TABLE[nibble];\n  if (state.index < 0) {\n    state.index = 0;\n  } else if (state.index > 88) {\n    state.index = 88;\n  }\n  state.step = STEP_TABLE[state.index];\n}\n\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n * @private\r\n */\nfunction blockHead_(sample, state) {\n  encodeSample_(sample, state);\n  /** @type {!Array<number>} */\n  let adpcmSamples = [];\n  adpcmSamples.push(sample & 0xFF);\n  adpcmSamples.push(sample >> 8 & 0xFF);\n  adpcmSamples.push(state.index);\n  adpcmSamples.push(0);\n  return adpcmSamples;\n}","map":{"version":3,"names":["INDEX_TABLE","STEP_TABLE","encode","samples","state","index","predicted","step","adpcmSamples","Uint8Array","length","block","fileIndex","blockCount","i","len","set","encodeBlock","push","samplesLength","slice","decode","blockAlign","Int16Array","decoded","decodeBlock","blockHead_","sample2","encodeSample_","sample","sign_","result","original_sample","second_sample","first_sample","decodeSample_","num","delta","value","diff","updateEncoder_","nibble","difference","updateDecoder_"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/codecs/imaadpcm.js"],"sourcesContent":["/*\r\n * imaadpcm: IMA ADPCM codec in JavaScript.\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2016 acida. MIT License.  \r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview IMA ADPCM codec.\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://github.com/rochars/imaadpcm\r\n */\r\n\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst INDEX_TABLE = [\r\n    -1, -1, -1, -1, 2, 4, 6, 8,\r\n    -1, -1, -1, -1, 2, 4, 6, 8];\r\n/**\r\n * @type {!Array<number>}\r\n * @private\r\n */\r\nconst STEP_TABLE = [\r\n    7, 8, 9, 10, 11, 12, 13, 14,\r\n    16, 17, 19, 21, 23, 25, 28, 31,\r\n    34, 37, 41, 45, 50, 55, 60, 66,\r\n    73, 80, 88, 97, 107, 118, 130, 143,\r\n    157, 173, 190, 209, 230, 253, 279, 307,\r\n    337, 371, 408, 449, 494, 544, 598, 658,\r\n    724, 796, 876, 963, 1060, 1166, 1282, 1411,\r\n    1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024,\r\n    3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484,\r\n    7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899,\r\n    15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794,\r\n    32767];\r\n\r\n/**\r\n * Encode 16-bit PCM samples into 4-bit IMA ADPCM samples.\r\n * @param {!Int16Array} samples A array of samples.\r\n * @return {!Uint8Array}\r\n */\r\nexport function encode(samples) {\r\n  /** @type {!Object} */\r\n  let state = {\r\n    index: 0,\r\n    predicted: 0,\r\n    step: 7\r\n  };\r\n  /** @type {!Uint8Array} */\r\n  let adpcmSamples = new Uint8Array((samples.length));\r\n  /** @type {!Array<number>} */\r\n  let block = [];\r\n  /** @type {number} */\r\n  let fileIndex = 0;\r\n  /** @type {number} */\r\n  let blockCount = 0;\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    if ((i % 505 == 0 && i != 0)) {\r\n      adpcmSamples.set(encodeBlock(block, state), fileIndex);\r\n      fileIndex += 256;\r\n      block = [];\r\n      blockCount++;\r\n    }\r\n    block.push(samples[i]);\r\n  }\r\n  let samplesLength = samples.length / 2;\r\n  if (samplesLength % 2) {\r\n    samplesLength++;\r\n  }\r\n  return adpcmSamples.slice(0, samplesLength + 512 + blockCount * 4);\r\n}\r\n\r\n/**\r\n * Decode IMA ADPCM samples into 16-bit PCM samples.\r\n * @param {!Uint8Array} adpcmSamples A array of ADPCM samples.\r\n * @param {number} blockAlign The block size.\r\n * @return {!Int16Array}\r\n */\r\nexport function decode(adpcmSamples, blockAlign=256) {\r\n  /** @type {!Object} */\r\n  let state = {\r\n    index: 0,\r\n    predicted: 0,\r\n    step: 7\r\n  };\r\n  /** @type {!Int16Array} */\r\n  let samples = new Int16Array(adpcmSamples.length * 2);\r\n  /** @type {!Array<number>} */\r\n  let block = [];\r\n  /** @type {number} */\r\n  let fileIndex = 0;\r\n  for (let i = 0, len = adpcmSamples.length; i < len; i++) {\r\n    if (i % blockAlign == 0 && i != 0) {            \r\n      let decoded = decodeBlock(block, state);\r\n      samples.set(decoded, fileIndex);\r\n      fileIndex += decoded.length;\r\n      block = [];\r\n    }\r\n    block.push(adpcmSamples[i]);\r\n  }\r\n  return samples;\r\n}\r\n\r\n/**\r\n * Encode a block of 505 16-bit samples as 4-bit ADPCM samples.\r\n * @param {!Array<number>} block A sample block of 505 samples.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n */\r\nfunction encodeBlock(block, state) {\r\n  /** @type {!Array<number>} */\r\n  let adpcmSamples = blockHead_(block[0], state);\r\n  for (let i = 3, len = block.length; i < len; i+=2) {\r\n    /** @type {number} */\r\n    let sample2 = encodeSample_(block[i], state);\r\n    /** @type {number} */\r\n    let sample = encodeSample_(block[i + 1], state);\r\n    adpcmSamples.push((sample << 4) | sample2);\r\n  }\r\n  return adpcmSamples;\r\n}\r\n\r\n/**\r\n * Decode a block of ADPCM samples into 16-bit PCM samples.\r\n * @param {!Array<number>} block A adpcm sample block.\r\n * @param {!Object} state The decoder state.\r\n * @return {!Array<number>}\r\n */\r\nfunction decodeBlock(block, state) {\r\n  state.predicted = sign_((block[1] << 8) | block[0]);\r\n  state.index = block[2];\r\n  state.step = STEP_TABLE[state.index];\r\n  /** @type {!Array<number>} */\r\n  let result = [\r\n      state.predicted,\r\n      state.predicted\r\n    ];\r\n  for (let i = 4, len = block.length; i < len; i++) {\r\n    /** @type {number} */\r\n    let original_sample = block[i];\r\n    /** @type {number} */\r\n    let second_sample = original_sample >> 4;\r\n    /** @type {number} */\r\n    let first_sample = (second_sample << 4) ^ original_sample;\r\n    result.push(decodeSample_(first_sample, state));\r\n    result.push(decodeSample_(second_sample, state));\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * Sign a 16-bit integer.\r\n * @param {number} num A 16-bit integer.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction sign_(num) {\r\n  return num > 32768 ? num - 65536 : num;\r\n}\r\n\r\n/**\r\n * Compress a 16-bit PCM sample into a 4-bit ADPCM sample.\r\n * @param {number} sample The sample.\r\n * @param {!Object} state The encoder state.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction encodeSample_(sample, state) {\r\n  /** @type {number} */\r\n  let delta = sample - state.predicted;\r\n  /** @type {number} */\r\n  let value = 0;\r\n  if (delta >= 0) {\r\n    value = 0;\r\n  } else {\r\n    value = 8;\r\n    delta = -delta;\r\n  }\r\n  /** @type {number} */\r\n  let step = STEP_TABLE[state.index];\r\n  /** @type {number} */\r\n  let diff = step >> 3;\r\n  if (delta > step) {\r\n    value |= 4;\r\n    delta -= step;\r\n    diff += step;\r\n  }\r\n  step >>= 1;\r\n  if (delta > step) {\r\n    value |= 2;\r\n    delta -= step;\r\n    diff += step;\r\n  }\r\n  step >>= 1;\r\n  if (delta > step) {\r\n    value |= 1;\r\n    diff += step;\r\n  }\r\n  updateEncoder_(value, diff, state);\r\n  return value;\r\n}\r\n\r\n/**\r\n * Set the value for encoderPredicted_ and encoderIndex_\r\n * after each sample is compressed.\r\n * @param {number} value The compressed ADPCM sample\r\n * @param {number} diff The calculated difference\r\n * @param {!Object} state The encoder state.\r\n * @private\r\n */\r\nfunction updateEncoder_(value, diff, state) {\r\n  if (value & 8) {\r\n    state.predicted -= diff;\r\n  } else {\r\n    state.predicted += diff;\r\n  }\r\n  if (state.predicted < -0x8000) {\r\n    state.predicted = -0x8000;\r\n  } else if (state.predicted > 0x7fff) {\r\n    state.predicted = 0x7fff;\r\n  }\r\n  state.index += INDEX_TABLE[value & 7];\r\n  if (state.index < 0) {\r\n    state.index = 0;\r\n  } else if (state.index > 88) {\r\n    state.index = 88;\r\n  }\r\n}\r\n\r\n/**\r\n * Decode a 4-bit ADPCM sample into a 16-bit PCM sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction decodeSample_(nibble, state) {\r\n  /** @type {number} */\r\n  let difference = 0;\r\n  if (nibble & 4) {\r\n    difference += state.step;\r\n  }\r\n  if (nibble & 2) {\r\n    difference += state.step >> 1;\r\n  }\r\n  if (nibble & 1) {\r\n    difference += state.step >> 2;\r\n  }\r\n  difference += state.step >> 3;\r\n  if (nibble & 8) {\r\n    difference = -difference;\r\n  }\r\n  state.predicted += difference;\r\n  if (state.predicted > 32767) {\r\n    state.predicted = 32767;\r\n  } else if (state.predicted < -32767) {\r\n    state.predicted = -32767;\r\n  }\r\n  updateDecoder_(nibble, state);\r\n  return state.predicted;\r\n}\r\n\r\n/**\r\n * Update the index and step after decoding a sample.\r\n * @param {number} nibble A 4-bit adpcm sample.\r\n * @param {!Object} state The decoder state.\r\n * @private\r\n */\r\nfunction updateDecoder_(nibble, state) {\r\n  state.index += INDEX_TABLE[nibble];\r\n  if (state.index < 0) {\r\n    state.index = 0;\r\n  } else if (state.index > 88) {\r\n    state.index = 88;\r\n  }\r\n  state.step = STEP_TABLE[state.index];\r\n}\r\n\r\n/**\r\n * Return the head of a ADPCM sample block.\r\n * @param {number} sample The first sample of the block.\r\n * @param {!Object} state The encoder state.\r\n * @return {!Array<number>}\r\n * @private\r\n */\r\nfunction blockHead_(sample, state) {\r\n  encodeSample_(sample, state);\r\n  /** @type {!Array<number>} */\r\n  let adpcmSamples = [];\r\n  adpcmSamples.push(sample & 0xFF);\r\n  adpcmSamples.push((sample >> 8) & 0xFF);\r\n  adpcmSamples.push(state.index);\r\n  adpcmSamples.push(0);\r\n  return adpcmSamples;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}