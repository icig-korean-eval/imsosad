{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\n\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\nexport class WaveFileCueEditor extends WaveFileTagEditor {\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * Objects representing cue points/regions look like this:\r\n   *   {\r\n   *     position: 500, // the position in milliseconds\r\n   *     label: 'cue marker 1',\r\n   *     end: 1500, // the end position in milliseconds\r\n   *     dwName: 1,\r\n   *     dwPosition: 0,\r\n   *     fccChunk: 'data',\r\n   *     dwChunkStart: 0,\r\n   *     dwBlockStart: 0,\r\n   *     dwSampleOffset: 22050, // the position as a sample offset\r\n   *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n   *     dwPurposeID: 544106354,\r\n   *     dwCountry: 0,\r\n   *     dwLanguage: 0,\r\n   *     dwDialect: 0,\r\n   *     dwCodePage: 0,\r\n   *   }\r\n   * @return {!Array<Object>}\r\n   */\n  listCuePoints() {\n    /** @type {!Array<!Object>} */\n    let points = this.getCuePoints_();\n    for (let i = 0, len = points.length; i < len; i++) {\n      // Add attrs that should exist in the object\n      points[i].position = points[i].dwSampleOffset / this.fmt.sampleRate * 1000;\n\n      // If it is a region, calc the end\n      // position in milliseconds\n      if (points[i].dwSampleLength) {\n        points[i].end = points[i].dwSampleLength / this.fmt.sampleRate * 1000;\n        points[i].end += points[i].position;\n        // If its not a region, end should be null\n      } else {\n        points[i].end = null;\n      }\n\n      // Remove attrs that should not go in the results\n      delete points[i].value;\n    }\n    return points;\n  }\n\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {!{\r\n   *   position: number,\r\n   *   label: ?string,\r\n   *   end: ?number,\r\n   *   dwPurposeID: ?number,\r\n   *   dwCountry: ?number,\r\n   *   dwLanguage: ?number,\r\n   *   dwDialect: ?number,\r\n   *   dwCodePage: ?number\r\n   * }} pointData A object with the data of the cue point.\r\n   *\r\n   * # Only required attribute to create a cue point:\r\n   * pointData.position: The position of the point in milliseconds\r\n   *\r\n   * # Optional attribute for cue points:\r\n   * pointData.label: A string label for the cue point\r\n   *\r\n   * # Extra data used for regions\r\n   * pointData.end: A number representing the end of the region,\r\n   *   in milliseconds, counting from the start of the file. If\r\n   *   no end attr is specified then no region is created.\r\n   *\r\n   * # You may also specify the following attrs for regions, all optional:\r\n   * pointData.dwPurposeID\r\n   * pointData.dwCountry\r\n   * pointData.dwLanguage\r\n   * pointData.dwDialect\r\n   * pointData.dwCodePage\r\n   */\n  setCuePoint(pointData) {\n    this.cue.chunkId = 'cue ';\n\n    // label attr should always exist\n    if (!pointData.label) {\n      pointData.label = '';\n    }\n\n    /**\r\n     * Load the existing points before erasing\r\n     * the LIST 'adtl' chunk and the cue attr\r\n     * @type {!Array<!Object>}\r\n     */\n    let existingPoints = this.getCuePoints_();\n\n    // Clear any LIST labeled 'adtl'\n    // The LIST chunk should be re-written\n    // after the new cue point is created\n    this.clearLISTadtl_();\n\n    // Erase this.cue so it can be re-written\n    // after the point is added\n    this.cue.points = [];\n\n    /**\r\n     * Cue position param is informed in milliseconds,\r\n     * here its value is converted to the sample offset\r\n     * @type {number}\r\n     */\n    pointData.dwSampleOffset = pointData.position * this.fmt.sampleRate / 1000;\n    /**\r\n     * end param is informed in milliseconds, counting\r\n     * from the start of the file.\r\n     * here its value is converted to the sample length\r\n     * of the region.\r\n     * @type {number}\r\n     */\n    pointData.dwSampleLength = 0;\n    if (pointData.end) {\n      pointData.dwSampleLength = pointData.end * this.fmt.sampleRate / 1000 - pointData.dwSampleOffset;\n    }\n\n    // If there were no cue points in the file,\n    // insert the new cue point as the first\n    if (existingPoints.length === 0) {\n      this.setCuePoint_(pointData, 1);\n\n      // If the file already had cue points, This new one\n      // must be added in the list according to its position.\n    } else {\n      this.setCuePointInOrder_(existingPoints, pointData);\n    }\n    this.cue.dwCuePoints = this.cue.points.length;\n  }\n\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   */\n  deleteCuePoint(index) {\n    this.cue.chunkId = 'cue ';\n    /** @type {!Array<!Object>} */\n    let existingPoints = this.getCuePoints_();\n    this.clearLISTadtl_();\n    /** @type {number} */\n    let len = this.cue.points.length;\n    this.cue.points = [];\n    for (let i = 0; i < len; i++) {\n      if (i + 1 !== index) {\n        this.setCuePoint_(existingPoints[i], i + 1);\n      }\n    }\n    this.cue.dwCuePoints = this.cue.points.length;\n    if (this.cue.dwCuePoints) {\n      this.cue.chunkId = 'cue ';\n    } else {\n      this.cue.chunkId = '';\n      this.clearLISTadtl_();\n    }\n  }\n\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   */\n  updateLabel(pointIndex, label) {\n    /** @type {?number} */\n    let cIndex = this.getLISTIndex('adtl');\n    if (cIndex !== null) {\n      for (let i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\n        if (this.LIST[cIndex].subChunks[i].dwName == pointIndex) {\n          this.LIST[cIndex].subChunks[i].value = label;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\n  getCuePoints_() {\n    /** @type {!Array<!Object>} */\n    let points = [];\n    for (let i = 0; i < this.cue.points.length; i++) {\n      /** @type {!Object} */\n      let chunk = this.cue.points[i];\n      /** @type {!Object} */\n      let pointData = this.getDataForCuePoint_(chunk.dwName);\n      pointData.label = pointData.value ? pointData.value : '';\n      pointData.dwPosition = chunk.dwPosition;\n      pointData.fccChunk = chunk.fccChunk;\n      pointData.dwChunkStart = chunk.dwChunkStart;\n      pointData.dwBlockStart = chunk.dwBlockStart;\n      pointData.dwSampleOffset = chunk.dwSampleOffset;\n      points.push(pointData);\n    }\n    return points;\n  }\n\n  /**\r\n   * Return the associated data of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {!Object}\r\n   * @private\r\n   */\n  getDataForCuePoint_(pointDwName) {\n    /** @type {?number} */\n    let LISTindex = this.getLISTIndex('adtl');\n    /** @type {!Object} */\n    let pointData = {};\n    // If there is a adtl LIST in the file, look for\n    // LIST subchunks with data referencing this point\n    if (LISTindex !== null) {\n      this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\n    }\n    return pointData;\n  }\n\n  /**\r\n   * Get all data associated to a cue point in a LIST chunk.\r\n   * @param {!Object} pointData A object to hold the point data.\r\n   * @param {number} index The index of the adtl LIST chunk.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @private\r\n   */\n  getCueDataFromLIST_(pointData, index, pointDwName) {\n    // got through all chunks in the adtl LIST checking\n    // for references to this cue point\n    for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\n      if (this.LIST[index].subChunks[i].dwName == pointDwName) {\n        /** @type {!Object} */\n        let chunk = this.LIST[index].subChunks[i];\n        // Some chunks may reference the point but\n        // have a empty text; this is to ensure that if\n        // one chunk that reference the point has a text,\n        // this value will be kept as the associated data label\n        // for the cue point.\n        // If different values are present, the last value found\n        // will be considered the label for the cue point.\n        pointData.value = chunk.value || pointData.value;\n        pointData.dwName = chunk.dwName || 0;\n        pointData.dwSampleLength = chunk.dwSampleLength || 0;\n        pointData.dwPurposeID = chunk.dwPurposeID || 0;\n        pointData.dwCountry = chunk.dwCountry || 0;\n        pointData.dwLanguage = chunk.dwLanguage || 0;\n        pointData.dwDialect = chunk.dwDialect || 0;\n        pointData.dwCodePage = chunk.dwCodePage || 0;\n      }\n    }\n  }\n\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\n  setCuePoint_(pointData, dwName) {\n    this.cue.points.push({\n      dwName: dwName,\n      dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\n      fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\n      dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\n      dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\n      dwSampleOffset: pointData.dwSampleOffset\n    });\n    this.setLabl_(pointData, dwName);\n  }\n\n  /**\r\n   * Push a new cue point in this.cue.points according to existing cue points.\r\n   * @param {!Array} existingPoints Array with the existing points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @private\r\n   */\n  setCuePointInOrder_(existingPoints, pointData) {\n    /** @type {boolean} */\n    let hasSet = false;\n\n    // Iterate over the cue points that existed\n    // before this one was added\n    for (let i = 0; i < existingPoints.length; i++) {\n      // If the new point is located before this original point\n      // and the new point have not been created, create the\n      // new point and then the original point\n      if (existingPoints[i].dwSampleOffset > pointData.dwSampleOffset && !hasSet) {\n        // create the new point\n        this.setCuePoint_(pointData, i + 1);\n\n        // create the original point\n        this.setCuePoint_(existingPoints[i], i + 2);\n        hasSet = true;\n\n        // Otherwise, re-create the original point\n      } else {\n        this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\n      }\n    }\n    // If no point was created in the above loop,\n    // create the new point as the last one\n    if (!hasSet) {\n      this.setCuePoint_(pointData, this.cue.points.length + 1);\n    }\n  }\n\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\n  clearLISTadtl_() {\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\n      if (this.LIST[i].format == 'adtl') {\n        this.LIST.splice(i);\n      }\n    }\n  }\n\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * This method creates a LIST adtl chunk in the file if one\r\n   * is not present.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\n  setLabl_(pointData, dwName) {\n    /**\r\n     * Get the index of the LIST chunk labeled as adtl.\r\n     * A file can have many LIST chunks with unique labels.\r\n     * @type {?number}\r\n     */\n    let adtlIndex = this.getLISTIndex('adtl');\n    // If there is no adtl LIST, create one\n    if (adtlIndex === null) {\n      // Include a new item LIST chunk\n      this.LIST.push({\n        chunkId: 'LIST',\n        chunkSize: 4,\n        format: 'adtl',\n        subChunks: []\n      });\n      // Get the index of the new LIST chunk\n      adtlIndex = this.LIST.length - 1;\n    }\n    this.setLabelText_(adtlIndex, pointData, dwName);\n    if (pointData.dwSampleLength) {\n      this.setLtxtChunk_(adtlIndex, pointData, dwName);\n    }\n  }\n\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\n  setLabelText_(adtlIndex, pointData, dwName) {\n    this.LIST[adtlIndex].subChunks.push({\n      chunkId: 'labl',\n      chunkSize: 4,\n      // should be 4 + label length in bytes\n      dwName: dwName,\n      value: pointData.label\n    });\n    this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\n  }\n  /**\r\n   * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\n  setLtxtChunk_(adtlIndex, pointData, dwName) {\n    this.LIST[adtlIndex].subChunks.push({\n      chunkId: 'ltxt',\n      chunkSize: 20,\n      // should be 12 + label byte length\n      dwName: dwName,\n      dwSampleLength: pointData.dwSampleLength,\n      dwPurposeID: pointData.dwPurposeID || 0,\n      dwCountry: pointData.dwCountry || 0,\n      dwLanguage: pointData.dwLanguage || 0,\n      dwDialect: pointData.dwDialect || 0,\n      dwCodePage: pointData.dwCodePage || 0,\n      value: pointData.label // kept for compatibility\n    });\n    this.LIST[adtlIndex].chunkSize += 28;\n  }\n}","map":{"version":3,"names":["WaveFileTagEditor","WaveFileCueEditor","listCuePoints","points","getCuePoints_","i","len","length","position","dwSampleOffset","fmt","sampleRate","dwSampleLength","end","value","setCuePoint","pointData","cue","chunkId","label","existingPoints","clearLISTadtl_","setCuePoint_","setCuePointInOrder_","dwCuePoints","deleteCuePoint","index","updateLabel","pointIndex","cIndex","getLISTIndex","LIST","subChunks","dwName","chunk","getDataForCuePoint_","dwPosition","fccChunk","dwChunkStart","dwBlockStart","push","pointDwName","LISTindex","getCueDataFromLIST_","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","setLabl_","hasSet","format","splice","adtlIndex","chunkSize","setLabelText_","setLtxtChunk_"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/wavefile-cue-editor.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCueEditor class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileTagEditor } from './wavefile-tag-editor';\r\n\r\n/**\r\n * A class to edit meta information in wav files.\r\n * @extends WaveFileTagEditor\r\n * @ignore\r\n */\r\nexport class WaveFileCueEditor extends WaveFileTagEditor {\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * Objects representing cue points/regions look like this:\r\n   *   {\r\n   *     position: 500, // the position in milliseconds\r\n   *     label: 'cue marker 1',\r\n   *     end: 1500, // the end position in milliseconds\r\n   *     dwName: 1,\r\n   *     dwPosition: 0,\r\n   *     fccChunk: 'data',\r\n   *     dwChunkStart: 0,\r\n   *     dwBlockStart: 0,\r\n   *     dwSampleOffset: 22050, // the position as a sample offset\r\n   *     dwSampleLength: 3646827, // length as a sample count, 0 if not a region\r\n   *     dwPurposeID: 544106354,\r\n   *     dwCountry: 0,\r\n   *     dwLanguage: 0,\r\n   *     dwDialect: 0,\r\n   *     dwCodePage: 0,\r\n   *   }\r\n   * @return {!Array<Object>}\r\n   */\r\n  listCuePoints() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = this.getCuePoints_();\r\n    for (let i = 0, len = points.length; i < len; i++) {\r\n\r\n      // Add attrs that should exist in the object\r\n      points[i].position =\r\n        (points[i].dwSampleOffset / this.fmt.sampleRate) * 1000;\r\n\r\n      // If it is a region, calc the end\r\n      // position in milliseconds\r\n      if (points[i].dwSampleLength) {\r\n        points[i].end =\r\n          (points[i].dwSampleLength / this.fmt.sampleRate) * 1000;\r\n        points[i].end += points[i].position;\r\n      // If its not a region, end should be null\r\n      } else {\r\n        points[i].end = null;\r\n      }\r\n\r\n      // Remove attrs that should not go in the results\r\n      delete points[i].value;\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Create a cue point in the wave file.\r\n   * @param {!{\r\n   *   position: number,\r\n   *   label: ?string,\r\n   *   end: ?number,\r\n   *   dwPurposeID: ?number,\r\n   *   dwCountry: ?number,\r\n   *   dwLanguage: ?number,\r\n   *   dwDialect: ?number,\r\n   *   dwCodePage: ?number\r\n   * }} pointData A object with the data of the cue point.\r\n   *\r\n   * # Only required attribute to create a cue point:\r\n   * pointData.position: The position of the point in milliseconds\r\n   *\r\n   * # Optional attribute for cue points:\r\n   * pointData.label: A string label for the cue point\r\n   *\r\n   * # Extra data used for regions\r\n   * pointData.end: A number representing the end of the region,\r\n   *   in milliseconds, counting from the start of the file. If\r\n   *   no end attr is specified then no region is created.\r\n   *\r\n   * # You may also specify the following attrs for regions, all optional:\r\n   * pointData.dwPurposeID\r\n   * pointData.dwCountry\r\n   * pointData.dwLanguage\r\n   * pointData.dwDialect\r\n   * pointData.dwCodePage\r\n   */\r\n  setCuePoint(pointData) {\r\n    this.cue.chunkId = 'cue ';\r\n\r\n    // label attr should always exist\r\n    if (!pointData.label) {\r\n      pointData.label = '';\r\n    }\r\n\r\n    /**\r\n     * Load the existing points before erasing\r\n     * the LIST 'adtl' chunk and the cue attr\r\n     * @type {!Array<!Object>}\r\n     */\r\n    let existingPoints = this.getCuePoints_();\r\n\r\n    // Clear any LIST labeled 'adtl'\r\n    // The LIST chunk should be re-written\r\n    // after the new cue point is created\r\n    this.clearLISTadtl_();\r\n\r\n    // Erase this.cue so it can be re-written\r\n    // after the point is added\r\n    this.cue.points = [];\r\n\r\n    /**\r\n     * Cue position param is informed in milliseconds,\r\n     * here its value is converted to the sample offset\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleOffset =\r\n      (pointData.position * this.fmt.sampleRate) / 1000;\r\n    /**\r\n     * end param is informed in milliseconds, counting\r\n     * from the start of the file.\r\n     * here its value is converted to the sample length\r\n     * of the region.\r\n     * @type {number}\r\n     */\r\n    pointData.dwSampleLength = 0;\r\n    if (pointData.end) {\r\n      pointData.dwSampleLength = \r\n        ((pointData.end * this.fmt.sampleRate) / 1000) -\r\n        pointData.dwSampleOffset;\r\n    }\r\n\r\n    // If there were no cue points in the file,\r\n    // insert the new cue point as the first\r\n    if (existingPoints.length === 0) {\r\n      this.setCuePoint_(pointData, 1);\r\n\r\n    // If the file already had cue points, This new one\r\n    // must be added in the list according to its position.\r\n    } else {\r\n      this.setCuePointInOrder_(existingPoints, pointData);\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n  }\r\n\r\n  /**\r\n   * Remove a cue point from a wave file.\r\n   * @param {number} index the index of the point. First is 1,\r\n   *    second is 2, and so on.\r\n   */\r\n  deleteCuePoint(index) {\r\n    this.cue.chunkId = 'cue ';\r\n    /** @type {!Array<!Object>} */\r\n    let existingPoints = this.getCuePoints_();\r\n    this.clearLISTadtl_();\r\n    /** @type {number} */\r\n    let len = this.cue.points.length;\r\n    this.cue.points = [];\r\n    for (let i = 0; i < len; i++) {\r\n      if (i + 1 !== index) {\r\n        this.setCuePoint_(existingPoints[i], i + 1);\r\n      }\r\n    }\r\n    this.cue.dwCuePoints = this.cue.points.length;\r\n    if (this.cue.dwCuePoints) {\r\n      this.cue.chunkId = 'cue ';\r\n    } else {\r\n      this.cue.chunkId = '';\r\n      this.clearLISTadtl_();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Update the label of a cue point.\r\n   * @param {number} pointIndex The ID of the cue point.\r\n   * @param {string} label The new text for the label.\r\n   */\r\n  updateLabel(pointIndex, label) {\r\n    /** @type {?number} */\r\n    let cIndex = this.getLISTIndex('adtl');\r\n    if (cIndex !== null) {\r\n      for (let i = 0, len = this.LIST[cIndex].subChunks.length; i < len; i++) {\r\n        if (this.LIST[cIndex].subChunks[i].dwName ==\r\n            pointIndex) {\r\n          this.LIST[cIndex].subChunks[i].value = label;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an array with all cue points in the file, in the order they appear\r\n   * in the file.\r\n   * @return {!Array<!Object>}\r\n   * @private\r\n   */\r\n  getCuePoints_() {\r\n    /** @type {!Array<!Object>} */\r\n    let points = [];\r\n    for (let i = 0; i < this.cue.points.length; i++) {\r\n      /** @type {!Object} */\r\n      let chunk = this.cue.points[i];\r\n      /** @type {!Object} */\r\n      let pointData = this.getDataForCuePoint_(chunk.dwName);\r\n      pointData.label = pointData.value ? pointData.value : '';\r\n      pointData.dwPosition = chunk.dwPosition;\r\n      pointData.fccChunk = chunk.fccChunk;\r\n      pointData.dwChunkStart = chunk.dwChunkStart;\r\n      pointData.dwBlockStart = chunk.dwBlockStart;\r\n      pointData.dwSampleOffset = chunk.dwSampleOffset;\r\n      points.push(pointData);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Return the associated data of a cue point.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @return {!Object}\r\n   * @private\r\n   */\r\n  getDataForCuePoint_(pointDwName) {\r\n    /** @type {?number} */\r\n    let LISTindex = this.getLISTIndex('adtl');\r\n    /** @type {!Object} */\r\n    let pointData = {};\r\n    // If there is a adtl LIST in the file, look for\r\n    // LIST subchunks with data referencing this point\r\n    if (LISTindex !== null) {\r\n      this.getCueDataFromLIST_(pointData, LISTindex, pointDwName);\r\n    }\r\n    return pointData;\r\n  }\r\n\r\n  /**\r\n   * Get all data associated to a cue point in a LIST chunk.\r\n   * @param {!Object} pointData A object to hold the point data.\r\n   * @param {number} index The index of the adtl LIST chunk.\r\n   * @param {number} pointDwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  getCueDataFromLIST_(pointData, index, pointDwName) {\r\n    // got through all chunks in the adtl LIST checking\r\n    // for references to this cue point\r\n    for (let i = 0, len = this.LIST[index].subChunks.length; i < len; i++) {\r\n      if (this.LIST[index].subChunks[i].dwName == pointDwName) {\r\n        /** @type {!Object} */\r\n        let chunk = this.LIST[index].subChunks[i];\r\n        // Some chunks may reference the point but\r\n        // have a empty text; this is to ensure that if\r\n        // one chunk that reference the point has a text,\r\n        // this value will be kept as the associated data label\r\n        // for the cue point.\r\n        // If different values are present, the last value found\r\n        // will be considered the label for the cue point.\r\n        pointData.value = chunk.value || pointData.value;\r\n        pointData.dwName = chunk.dwName || 0;\r\n        pointData.dwSampleLength = chunk.dwSampleLength || 0;\r\n        pointData.dwPurposeID = chunk.dwPurposeID || 0;\r\n        pointData.dwCountry = chunk.dwCountry || 0;\r\n        pointData.dwLanguage = chunk.dwLanguage || 0;\r\n        pointData.dwDialect = chunk.dwDialect || 0;\r\n        pointData.dwCodePage = chunk.dwCodePage || 0;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName the dwName of the cue point\r\n   * @private\r\n   */\r\n  setCuePoint_(pointData, dwName) {\r\n    this.cue.points.push({\r\n      dwName: dwName,\r\n      dwPosition: pointData.dwPosition ? pointData.dwPosition : 0,\r\n      fccChunk: pointData.fccChunk ? pointData.fccChunk : 'data',\r\n      dwChunkStart: pointData.dwChunkStart ? pointData.dwChunkStart : 0,\r\n      dwBlockStart: pointData.dwBlockStart ? pointData.dwBlockStart : 0,\r\n      dwSampleOffset: pointData.dwSampleOffset\r\n    });\r\n    this.setLabl_(pointData, dwName);\r\n  }\r\n\r\n  /**\r\n   * Push a new cue point in this.cue.points according to existing cue points.\r\n   * @param {!Array} existingPoints Array with the existing points.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @private\r\n   */\r\n  setCuePointInOrder_(existingPoints, pointData) {\r\n    /** @type {boolean} */\r\n    let hasSet = false;\r\n\r\n    // Iterate over the cue points that existed\r\n    // before this one was added\r\n    for (let i = 0; i < existingPoints.length; i++) {\r\n\r\n      // If the new point is located before this original point\r\n      // and the new point have not been created, create the\r\n      // new point and then the original point\r\n      if (existingPoints[i].dwSampleOffset > \r\n        pointData.dwSampleOffset && !hasSet) {\r\n        // create the new point\r\n        this.setCuePoint_(pointData, i + 1);\r\n\r\n        // create the original point\r\n        this.setCuePoint_(existingPoints[i], i + 2);\r\n        hasSet = true;\r\n\r\n      // Otherwise, re-create the original point\r\n      } else {\r\n        this.setCuePoint_(existingPoints[i], hasSet ? i + 2 : i + 1);\r\n      }\r\n    }\r\n    // If no point was created in the above loop,\r\n    // create the new point as the last one\r\n    if (!hasSet) {\r\n      this.setCuePoint_(pointData, this.cue.points.length + 1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clear any LIST chunk labeled as 'adtl'.\r\n   * @private\r\n   */\r\n  clearLISTadtl_() {\r\n    for (let i = 0, len = this.LIST.length; i < len; i++) {\r\n      if (this.LIST[i].format == 'adtl') {\r\n        this.LIST.splice(i);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * This method creates a LIST adtl chunk in the file if one\r\n   * is not present.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabl_(pointData, dwName) {\r\n    /**\r\n     * Get the index of the LIST chunk labeled as adtl.\r\n     * A file can have many LIST chunks with unique labels.\r\n     * @type {?number}\r\n     */\r\n    let adtlIndex = this.getLISTIndex('adtl');\r\n    // If there is no adtl LIST, create one\r\n    if (adtlIndex === null) {\r\n      // Include a new item LIST chunk\r\n      this.LIST.push({\r\n        chunkId: 'LIST',\r\n        chunkSize: 4,\r\n        format: 'adtl',\r\n        subChunks: []});\r\n      // Get the index of the new LIST chunk\r\n      adtlIndex = this.LIST.length - 1;\r\n    }\r\n    this.setLabelText_(adtlIndex, pointData, dwName);\r\n    if (pointData.dwSampleLength) {\r\n      this.setLtxtChunk_(adtlIndex, pointData, dwName);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a new 'labl' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLabelText_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'labl',\r\n      chunkSize: 4, // should be 4 + label length in bytes\r\n      dwName: dwName,\r\n      value: pointData.label\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 12; // should be 4 + label byte length\r\n  }\r\n  /**\r\n   * Create a new 'ltxt' subchunk in a 'LIST' chunk of type 'adtl'.\r\n   * @param {number} adtlIndex The index of the 'adtl' LIST in this.LIST.\r\n   * @param {!Object} pointData A object with data of the cue point.\r\n   * @param {number} dwName The ID of the cue point.\r\n   * @private\r\n   */\r\n  setLtxtChunk_(adtlIndex, pointData, dwName) {\r\n    this.LIST[adtlIndex].subChunks.push({\r\n      chunkId: 'ltxt',\r\n      chunkSize: 20,  // should be 12 + label byte length\r\n      dwName: dwName,\r\n      dwSampleLength: pointData.dwSampleLength,\r\n      dwPurposeID: pointData.dwPurposeID || 0,\r\n      dwCountry: pointData.dwCountry || 0,\r\n      dwLanguage: pointData.dwLanguage || 0,\r\n      dwDialect: pointData.dwDialect || 0,\r\n      dwCodePage: pointData.dwCodePage || 0,\r\n      value: pointData.label // kept for compatibility\r\n    });\r\n    this.LIST[adtlIndex].chunkSize += 28;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAASA,iBAAiB,QAAQ,uBAAuB;;AAEzD;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,iBAAiB,SAASD,iBAAiB,CAAC;EAEvD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEE,aAAaA,CAAA,EAAG;IACd;IACA,IAAIC,MAAM,GAAG,IAAI,CAACC,aAAa,CAAC,CAAC;IACjC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGH,MAAM,CAACI,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAEjD;MACAF,MAAM,CAACE,CAAC,CAAC,CAACG,QAAQ,GACfL,MAAM,CAACE,CAAC,CAAC,CAACI,cAAc,GAAG,IAAI,CAACC,GAAG,CAACC,UAAU,GAAI,IAAI;;MAEzD;MACA;MACA,IAAIR,MAAM,CAACE,CAAC,CAAC,CAACO,cAAc,EAAE;QAC5BT,MAAM,CAACE,CAAC,CAAC,CAACQ,GAAG,GACVV,MAAM,CAACE,CAAC,CAAC,CAACO,cAAc,GAAG,IAAI,CAACF,GAAG,CAACC,UAAU,GAAI,IAAI;QACzDR,MAAM,CAACE,CAAC,CAAC,CAACQ,GAAG,IAAIV,MAAM,CAACE,CAAC,CAAC,CAACG,QAAQ;QACrC;MACA,CAAC,MAAM;QACLL,MAAM,CAACE,CAAC,CAAC,CAACQ,GAAG,GAAG,IAAI;MACtB;;MAEA;MACA,OAAOV,MAAM,CAACE,CAAC,CAAC,CAACS,KAAK;IACxB;IACA,OAAOX,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACEY,WAAWA,CAACC,SAAS,EAAE;IACrB,IAAI,CAACC,GAAG,CAACC,OAAO,GAAG,MAAM;;IAEzB;IACA,IAAI,CAACF,SAAS,CAACG,KAAK,EAAE;MACpBH,SAAS,CAACG,KAAK,GAAG,EAAE;IACtB;;IAEA;AACJ;AACA;AACA;AACA;IACI,IAAIC,cAAc,GAAG,IAAI,CAAChB,aAAa,CAAC,CAAC;;IAEzC;IACA;IACA;IACA,IAAI,CAACiB,cAAc,CAAC,CAAC;;IAErB;IACA;IACA,IAAI,CAACJ,GAAG,CAACd,MAAM,GAAG,EAAE;;IAEpB;AACJ;AACA;AACA;AACA;IACIa,SAAS,CAACP,cAAc,GACrBO,SAAS,CAACR,QAAQ,GAAG,IAAI,CAACE,GAAG,CAACC,UAAU,GAAI,IAAI;IACnD;AACJ;AACA;AACA;AACA;AACA;AACA;IACIK,SAAS,CAACJ,cAAc,GAAG,CAAC;IAC5B,IAAII,SAAS,CAACH,GAAG,EAAE;MACjBG,SAAS,CAACJ,cAAc,GACpBI,SAAS,CAACH,GAAG,GAAG,IAAI,CAACH,GAAG,CAACC,UAAU,GAAI,IAAI,GAC7CK,SAAS,CAACP,cAAc;IAC5B;;IAEA;IACA;IACA,IAAIW,cAAc,CAACb,MAAM,KAAK,CAAC,EAAE;MAC/B,IAAI,CAACe,YAAY,CAACN,SAAS,EAAE,CAAC,CAAC;;MAEjC;MACA;IACA,CAAC,MAAM;MACL,IAAI,CAACO,mBAAmB,CAACH,cAAc,EAAEJ,SAAS,CAAC;IACrD;IACA,IAAI,CAACC,GAAG,CAACO,WAAW,GAAG,IAAI,CAACP,GAAG,CAACd,MAAM,CAACI,MAAM;EAC/C;;EAEA;AACF;AACA;AACA;AACA;EACEkB,cAAcA,CAACC,KAAK,EAAE;IACpB,IAAI,CAACT,GAAG,CAACC,OAAO,GAAG,MAAM;IACzB;IACA,IAAIE,cAAc,GAAG,IAAI,CAAChB,aAAa,CAAC,CAAC;IACzC,IAAI,CAACiB,cAAc,CAAC,CAAC;IACrB;IACA,IAAIf,GAAG,GAAG,IAAI,CAACW,GAAG,CAACd,MAAM,CAACI,MAAM;IAChC,IAAI,CAACU,GAAG,CAACd,MAAM,GAAG,EAAE;IACpB,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MAC5B,IAAIA,CAAC,GAAG,CAAC,KAAKqB,KAAK,EAAE;QACnB,IAAI,CAACJ,YAAY,CAACF,cAAc,CAACf,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;MAC7C;IACF;IACA,IAAI,CAACY,GAAG,CAACO,WAAW,GAAG,IAAI,CAACP,GAAG,CAACd,MAAM,CAACI,MAAM;IAC7C,IAAI,IAAI,CAACU,GAAG,CAACO,WAAW,EAAE;MACxB,IAAI,CAACP,GAAG,CAACC,OAAO,GAAG,MAAM;IAC3B,CAAC,MAAM;MACL,IAAI,CAACD,GAAG,CAACC,OAAO,GAAG,EAAE;MACrB,IAAI,CAACG,cAAc,CAAC,CAAC;IACvB;EACF;;EAEA;AACF;AACA;AACA;AACA;EACEM,WAAWA,CAACC,UAAU,EAAET,KAAK,EAAE;IAC7B;IACA,IAAIU,MAAM,GAAG,IAAI,CAACC,YAAY,CAAC,MAAM,CAAC;IACtC,IAAID,MAAM,KAAK,IAAI,EAAE;MACnB,KAAK,IAAIxB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACyB,IAAI,CAACF,MAAM,CAAC,CAACG,SAAS,CAACzB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;QACtE,IAAI,IAAI,CAAC0B,IAAI,CAACF,MAAM,CAAC,CAACG,SAAS,CAAC3B,CAAC,CAAC,CAAC4B,MAAM,IACrCL,UAAU,EAAE;UACd,IAAI,CAACG,IAAI,CAACF,MAAM,CAAC,CAACG,SAAS,CAAC3B,CAAC,CAAC,CAACS,KAAK,GAAGK,KAAK;QAC9C;MACF;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEf,aAAaA,CAAA,EAAG;IACd;IACA,IAAID,MAAM,GAAG,EAAE;IACf,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACY,GAAG,CAACd,MAAM,CAACI,MAAM,EAAEF,CAAC,EAAE,EAAE;MAC/C;MACA,IAAI6B,KAAK,GAAG,IAAI,CAACjB,GAAG,CAACd,MAAM,CAACE,CAAC,CAAC;MAC9B;MACA,IAAIW,SAAS,GAAG,IAAI,CAACmB,mBAAmB,CAACD,KAAK,CAACD,MAAM,CAAC;MACtDjB,SAAS,CAACG,KAAK,GAAGH,SAAS,CAACF,KAAK,GAAGE,SAAS,CAACF,KAAK,GAAG,EAAE;MACxDE,SAAS,CAACoB,UAAU,GAAGF,KAAK,CAACE,UAAU;MACvCpB,SAAS,CAACqB,QAAQ,GAAGH,KAAK,CAACG,QAAQ;MACnCrB,SAAS,CAACsB,YAAY,GAAGJ,KAAK,CAACI,YAAY;MAC3CtB,SAAS,CAACuB,YAAY,GAAGL,KAAK,CAACK,YAAY;MAC3CvB,SAAS,CAACP,cAAc,GAAGyB,KAAK,CAACzB,cAAc;MAC/CN,MAAM,CAACqC,IAAI,CAACxB,SAAS,CAAC;IACxB;IACA,OAAOb,MAAM;EACf;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEgC,mBAAmBA,CAACM,WAAW,EAAE;IAC/B;IACA,IAAIC,SAAS,GAAG,IAAI,CAACZ,YAAY,CAAC,MAAM,CAAC;IACzC;IACA,IAAId,SAAS,GAAG,CAAC,CAAC;IAClB;IACA;IACA,IAAI0B,SAAS,KAAK,IAAI,EAAE;MACtB,IAAI,CAACC,mBAAmB,CAAC3B,SAAS,EAAE0B,SAAS,EAAED,WAAW,CAAC;IAC7D;IACA,OAAOzB,SAAS;EAClB;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACE2B,mBAAmBA,CAAC3B,SAAS,EAAEU,KAAK,EAAEe,WAAW,EAAE;IACjD;IACA;IACA,KAAK,IAAIpC,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACyB,IAAI,CAACL,KAAK,CAAC,CAACM,SAAS,CAACzB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACrE,IAAI,IAAI,CAAC0B,IAAI,CAACL,KAAK,CAAC,CAACM,SAAS,CAAC3B,CAAC,CAAC,CAAC4B,MAAM,IAAIQ,WAAW,EAAE;QACvD;QACA,IAAIP,KAAK,GAAG,IAAI,CAACH,IAAI,CAACL,KAAK,CAAC,CAACM,SAAS,CAAC3B,CAAC,CAAC;QACzC;QACA;QACA;QACA;QACA;QACA;QACA;QACAW,SAAS,CAACF,KAAK,GAAGoB,KAAK,CAACpB,KAAK,IAAIE,SAAS,CAACF,KAAK;QAChDE,SAAS,CAACiB,MAAM,GAAGC,KAAK,CAACD,MAAM,IAAI,CAAC;QACpCjB,SAAS,CAACJ,cAAc,GAAGsB,KAAK,CAACtB,cAAc,IAAI,CAAC;QACpDI,SAAS,CAAC4B,WAAW,GAAGV,KAAK,CAACU,WAAW,IAAI,CAAC;QAC9C5B,SAAS,CAAC6B,SAAS,GAAGX,KAAK,CAACW,SAAS,IAAI,CAAC;QAC1C7B,SAAS,CAAC8B,UAAU,GAAGZ,KAAK,CAACY,UAAU,IAAI,CAAC;QAC5C9B,SAAS,CAAC+B,SAAS,GAAGb,KAAK,CAACa,SAAS,IAAI,CAAC;QAC1C/B,SAAS,CAACgC,UAAU,GAAGd,KAAK,CAACc,UAAU,IAAI,CAAC;MAC9C;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;EACE1B,YAAYA,CAACN,SAAS,EAAEiB,MAAM,EAAE;IAC9B,IAAI,CAAChB,GAAG,CAACd,MAAM,CAACqC,IAAI,CAAC;MACnBP,MAAM,EAAEA,MAAM;MACdG,UAAU,EAAEpB,SAAS,CAACoB,UAAU,GAAGpB,SAAS,CAACoB,UAAU,GAAG,CAAC;MAC3DC,QAAQ,EAAErB,SAAS,CAACqB,QAAQ,GAAGrB,SAAS,CAACqB,QAAQ,GAAG,MAAM;MAC1DC,YAAY,EAAEtB,SAAS,CAACsB,YAAY,GAAGtB,SAAS,CAACsB,YAAY,GAAG,CAAC;MACjEC,YAAY,EAAEvB,SAAS,CAACuB,YAAY,GAAGvB,SAAS,CAACuB,YAAY,GAAG,CAAC;MACjE9B,cAAc,EAAEO,SAAS,CAACP;IAC5B,CAAC,CAAC;IACF,IAAI,CAACwC,QAAQ,CAACjC,SAAS,EAAEiB,MAAM,CAAC;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEV,mBAAmBA,CAACH,cAAc,EAAEJ,SAAS,EAAE;IAC7C;IACA,IAAIkC,MAAM,GAAG,KAAK;;IAElB;IACA;IACA,KAAK,IAAI7C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGe,cAAc,CAACb,MAAM,EAAEF,CAAC,EAAE,EAAE;MAE9C;MACA;MACA;MACA,IAAIe,cAAc,CAACf,CAAC,CAAC,CAACI,cAAc,GAClCO,SAAS,CAACP,cAAc,IAAI,CAACyC,MAAM,EAAE;QACrC;QACA,IAAI,CAAC5B,YAAY,CAACN,SAAS,EAAEX,CAAC,GAAG,CAAC,CAAC;;QAEnC;QACA,IAAI,CAACiB,YAAY,CAACF,cAAc,CAACf,CAAC,CAAC,EAAEA,CAAC,GAAG,CAAC,CAAC;QAC3C6C,MAAM,GAAG,IAAI;;QAEf;MACA,CAAC,MAAM;QACL,IAAI,CAAC5B,YAAY,CAACF,cAAc,CAACf,CAAC,CAAC,EAAE6C,MAAM,GAAG7C,CAAC,GAAG,CAAC,GAAGA,CAAC,GAAG,CAAC,CAAC;MAC9D;IACF;IACA;IACA;IACA,IAAI,CAAC6C,MAAM,EAAE;MACX,IAAI,CAAC5B,YAAY,CAACN,SAAS,EAAE,IAAI,CAACC,GAAG,CAACd,MAAM,CAACI,MAAM,GAAG,CAAC,CAAC;IAC1D;EACF;;EAEA;AACF;AACA;AACA;EACEc,cAAcA,CAAA,EAAG;IACf,KAAK,IAAIhB,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAG,IAAI,CAACyB,IAAI,CAACxB,MAAM,EAAEF,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;MACpD,IAAI,IAAI,CAAC0B,IAAI,CAAC1B,CAAC,CAAC,CAAC8C,MAAM,IAAI,MAAM,EAAE;QACjC,IAAI,CAACpB,IAAI,CAACqB,MAAM,CAAC/C,CAAC,CAAC;MACrB;IACF;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;EACE4C,QAAQA,CAACjC,SAAS,EAAEiB,MAAM,EAAE;IAC1B;AACJ;AACA;AACA;AACA;IACI,IAAIoB,SAAS,GAAG,IAAI,CAACvB,YAAY,CAAC,MAAM,CAAC;IACzC;IACA,IAAIuB,SAAS,KAAK,IAAI,EAAE;MACtB;MACA,IAAI,CAACtB,IAAI,CAACS,IAAI,CAAC;QACbtB,OAAO,EAAE,MAAM;QACfoC,SAAS,EAAE,CAAC;QACZH,MAAM,EAAE,MAAM;QACdnB,SAAS,EAAE;MAAE,CAAC,CAAC;MACjB;MACAqB,SAAS,GAAG,IAAI,CAACtB,IAAI,CAACxB,MAAM,GAAG,CAAC;IAClC;IACA,IAAI,CAACgD,aAAa,CAACF,SAAS,EAAErC,SAAS,EAAEiB,MAAM,CAAC;IAChD,IAAIjB,SAAS,CAACJ,cAAc,EAAE;MAC5B,IAAI,CAAC4C,aAAa,CAACH,SAAS,EAAErC,SAAS,EAAEiB,MAAM,CAAC;IAClD;EACF;;EAEA;AACF;AACA;AACA;AACA;AACA;AACA;EACEsB,aAAaA,CAACF,SAAS,EAAErC,SAAS,EAAEiB,MAAM,EAAE;IAC1C,IAAI,CAACF,IAAI,CAACsB,SAAS,CAAC,CAACrB,SAAS,CAACQ,IAAI,CAAC;MAClCtB,OAAO,EAAE,MAAM;MACfoC,SAAS,EAAE,CAAC;MAAE;MACdrB,MAAM,EAAEA,MAAM;MACdnB,KAAK,EAAEE,SAAS,CAACG;IACnB,CAAC,CAAC;IACF,IAAI,CAACY,IAAI,CAACsB,SAAS,CAAC,CAACC,SAAS,IAAI,EAAE,CAAC,CAAC;EACxC;EACA;AACF;AACA;AACA;AACA;AACA;AACA;EACEE,aAAaA,CAACH,SAAS,EAAErC,SAAS,EAAEiB,MAAM,EAAE;IAC1C,IAAI,CAACF,IAAI,CAACsB,SAAS,CAAC,CAACrB,SAAS,CAACQ,IAAI,CAAC;MAClCtB,OAAO,EAAE,MAAM;MACfoC,SAAS,EAAE,EAAE;MAAG;MAChBrB,MAAM,EAAEA,MAAM;MACdrB,cAAc,EAAEI,SAAS,CAACJ,cAAc;MACxCgC,WAAW,EAAE5B,SAAS,CAAC4B,WAAW,IAAI,CAAC;MACvCC,SAAS,EAAE7B,SAAS,CAAC6B,SAAS,IAAI,CAAC;MACnCC,UAAU,EAAE9B,SAAS,CAAC8B,UAAU,IAAI,CAAC;MACrCC,SAAS,EAAE/B,SAAS,CAAC+B,SAAS,IAAI,CAAC;MACnCC,UAAU,EAAEhC,SAAS,CAACgC,UAAU,IAAI,CAAC;MACrClC,KAAK,EAAEE,SAAS,CAACG,KAAK,CAAC;IACzB,CAAC,CAAC;IACF,IAAI,CAACY,IAAI,CAACsB,SAAS,CAAC,CAACC,SAAS,IAAI,EAAE;EACtC;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}