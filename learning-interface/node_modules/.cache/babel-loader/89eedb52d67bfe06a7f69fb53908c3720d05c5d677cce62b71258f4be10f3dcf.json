{"ast":null,"code":"/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The resample function.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { Interpolator } from './interpolator';\nimport { FIRLPF } from './fir-lpf';\nimport { ButterworthLPF } from './butterworth-lpf';\n\n/**\r\n * Default use of LPF for each resampling method.\r\n * @readonly\r\n * @enum {boolean}\r\n * @private\r\n */\nconst DEFAULT_LPF_USE = {\n  'point': false,\n  'linear': false,\n  'cubic': true,\n  'sinc': true\n};\n\n/**\r\n * Default LPF order for each type of LPF.\r\n * @readonly\r\n * @enum {number}\r\n * @private\r\n */\nconst DEFAULT_LPF_ORDER = {\n  'IIR': 16,\n  'FIR': 71\n};\n\n/**\r\n * Default LPF class for each type of LPF.\r\n * @readonly\r\n * @enum {!Function}\r\n * @private\r\n */\nconst DEFAULT_LPF = {\n  'IIR': ButterworthLPF,\n  'FIR': FIRLPF\n};\n\n/**\r\n * Change the sample rate of the samples to a new sample rate.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {number} oldSampleRate The original sample rate.\r\n * @param {number} sampleRate The target sample rate.\r\n * @param {Object=} options The extra configuration, if needed.\r\n * @return {!Float64Array} the new samples.\r\n */\nexport function resample(samples, oldSampleRate, sampleRate, options = null) {\n  options = options || {};\n  // Make the new sample container\n  /** @type {number} */\n  let rate = (sampleRate - oldSampleRate) / oldSampleRate + 1;\n  /** @type {!Float64Array} */\n  let newSamples = new Float64Array(samples.length * rate);\n  // Create the interpolator\n  options.method = options.method || 'cubic';\n  /** @type {!Object} */\n  let interpolator = new Interpolator(samples.length, newSamples.length, {\n    method: options.method,\n    tension: options.tension || 0,\n    sincFilterSize: options.sincFilterSize || 6,\n    sincWindow: options.sincWindow || undefined,\n    clip: options.clip || 'mirror'\n  });\n  // Resample + LPF\n  if (options.LPF === undefined) {\n    options.LPF = DEFAULT_LPF_USE[options.method];\n  }\n  if (options.LPF) {\n    options.LPFType = options.LPFType || 'IIR';\n    const LPF = DEFAULT_LPF[options.LPFType];\n    // Upsampling\n    if (sampleRate > oldSampleRate) {\n      /** @type {!Object} */\n      let filter = new LPF(options.LPForder || DEFAULT_LPF_ORDER[options.LPFType], sampleRate, oldSampleRate / 2);\n      upsample_(samples, newSamples, interpolator, filter);\n      // Downsampling\n    } else {\n      /** @type {!Object} */\n      let filter = new LPF(options.LPForder || DEFAULT_LPF_ORDER[options.LPFType], oldSampleRate, sampleRate / 2);\n      downsample_(samples, newSamples, interpolator, filter);\n    }\n    // Resample, no LPF\n  } else {\n    resample_(samples, newSamples, interpolator);\n  }\n  return newSamples;\n}\n\n/**\r\n * Resample.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @private\r\n */\nfunction resample_(samples, newSamples, interpolator) {\n  // Resample\n  for (let i = 0, len = newSamples.length; i < len; i++) {\n    newSamples[i] = interpolator.interpolate(i, samples);\n  }\n}\n\n/**\r\n * Upsample with LPF.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\nfunction upsample_(samples, newSamples, interpolator, filter) {\n  // Resample and filter\n  for (let i = 0, len = newSamples.length; i < len; i++) {\n    newSamples[i] = filter.filter(interpolator.interpolate(i, samples));\n  }\n  // Reverse filter\n  filter.reset();\n  for (let i = newSamples.length - 1; i >= 0; i--) {\n    newSamples[i] = filter.filter(newSamples[i]);\n  }\n}\n\n/**\r\n * Downsample with LPF.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\nfunction downsample_(samples, newSamples, interpolator, filter) {\n  // Filter\n  for (let i = 0, len = samples.length; i < len; i++) {\n    samples[i] = filter.filter(samples[i]);\n  }\n  // Reverse filter\n  filter.reset();\n  for (let i = samples.length - 1; i >= 0; i--) {\n    samples[i] = filter.filter(samples[i]);\n  }\n  // Resample\n  resample_(samples, newSamples, interpolator);\n}","map":{"version":3,"names":["Interpolator","FIRLPF","ButterworthLPF","DEFAULT_LPF_USE","DEFAULT_LPF_ORDER","DEFAULT_LPF","resample","samples","oldSampleRate","sampleRate","options","rate","newSamples","Float64Array","length","method","interpolator","tension","sincFilterSize","sincWindow","undefined","clip","LPF","LPFType","filter","LPForder","upsample_","downsample_","resample_","i","len","interpolate","reset"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/resampler/index.js"],"sourcesContent":["/*\r\n * Copyright (c) 2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The resample function.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { Interpolator } from './interpolator';\r\nimport { FIRLPF } from './fir-lpf';\r\nimport { ButterworthLPF } from './butterworth-lpf';\r\n\r\n/**\r\n * Default use of LPF for each resampling method.\r\n * @readonly\r\n * @enum {boolean}\r\n * @private\r\n */\r\nconst DEFAULT_LPF_USE = {\r\n  'point': false,\r\n  'linear': false,\r\n  'cubic': true,\r\n  'sinc': true\r\n};\r\n\r\n/**\r\n * Default LPF order for each type of LPF.\r\n * @readonly\r\n * @enum {number}\r\n * @private\r\n */\r\nconst DEFAULT_LPF_ORDER = {\r\n  'IIR': 16,\r\n  'FIR': 71\r\n};\r\n\r\n/**\r\n * Default LPF class for each type of LPF.\r\n * @readonly\r\n * @enum {!Function}\r\n * @private\r\n */\r\nconst DEFAULT_LPF = {\r\n  'IIR': ButterworthLPF,\r\n  'FIR': FIRLPF\r\n};\r\n\r\n/**\r\n * Change the sample rate of the samples to a new sample rate.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {number} oldSampleRate The original sample rate.\r\n * @param {number} sampleRate The target sample rate.\r\n * @param {Object=} options The extra configuration, if needed.\r\n * @return {!Float64Array} the new samples.\r\n */\r\nexport function resample(samples, oldSampleRate, sampleRate, options=null) {\r\n  options = options || {};\r\n  // Make the new sample container\r\n  /** @type {number} */\r\n  let rate = ((sampleRate - oldSampleRate) / oldSampleRate) + 1;\r\n  /** @type {!Float64Array} */\r\n  let newSamples = new Float64Array(samples.length * (rate));\r\n  // Create the interpolator\r\n  options.method = options.method || 'cubic';\r\n  /** @type {!Object} */\r\n  let interpolator = new Interpolator(\r\n    samples.length,\r\n    newSamples.length,\r\n    {\r\n      method: options.method,\r\n      tension: options.tension || 0,\r\n      sincFilterSize: options.sincFilterSize || 6,\r\n      sincWindow: options.sincWindow || undefined,\r\n      clip: options.clip || 'mirror'\r\n    });\r\n  // Resample + LPF\r\n  if (options.LPF === undefined) {\r\n    options.LPF = DEFAULT_LPF_USE[options.method];\r\n  } \r\n  if (options.LPF) {\r\n    options.LPFType = options.LPFType || 'IIR';\r\n    const LPF = DEFAULT_LPF[options.LPFType];\r\n    // Upsampling\r\n    if (sampleRate > oldSampleRate) {\r\n      /** @type {!Object} */\r\n      let filter = new LPF(\r\n        options.LPForder || DEFAULT_LPF_ORDER[options.LPFType],\r\n        sampleRate,\r\n        (oldSampleRate / 2));\r\n      upsample_(\r\n        samples, newSamples, interpolator, filter);\r\n    // Downsampling\r\n    } else {\r\n      /** @type {!Object} */\r\n      let filter = new LPF(\r\n        options.LPForder || DEFAULT_LPF_ORDER[options.LPFType],\r\n        oldSampleRate,\r\n        sampleRate / 2);\r\n      downsample_(\r\n        samples, newSamples, interpolator, filter);\r\n    }\r\n  // Resample, no LPF\r\n  } else {\r\n    resample_(samples, newSamples, interpolator);\r\n  }\r\n  return newSamples;\r\n}\r\n\r\n/**\r\n * Resample.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @private\r\n */\r\nfunction resample_(samples, newSamples, interpolator) {\r\n  // Resample\r\n  for (let i = 0, len = newSamples.length; i < len; i++) {\r\n    newSamples[i] = interpolator.interpolate(i, samples);\r\n  }\r\n}\r\n\r\n/**\r\n * Upsample with LPF.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\r\nfunction upsample_(samples, newSamples, interpolator, filter) {\r\n  // Resample and filter\r\n  for (let i = 0, len = newSamples.length; i < len; i++) {\r\n    newSamples[i] = filter.filter(interpolator.interpolate(i, samples));\r\n  }\r\n  // Reverse filter\r\n  filter.reset();\r\n  for (let i = newSamples.length - 1; i >= 0; i--) {\r\n    newSamples[i]  = filter.filter(newSamples[i]);\r\n  }\r\n}\r\n\r\n/**\r\n * Downsample with LPF.\r\n * @param {!Array<number>|!TypedArray} samples The original samples.\r\n * @param {!Float64Array} newSamples The container for the new samples.\r\n * @param {Object} interpolator The interpolator.\r\n * @param {Object} filter The LPF object.\r\n * @private\r\n */\r\nfunction downsample_(samples, newSamples, interpolator, filter) {\r\n  // Filter\r\n  for (let i = 0, len = samples.length; i < len; i++) {\r\n    samples[i]  = filter.filter(samples[i]);\r\n  }\r\n  // Reverse filter\r\n  filter.reset();\r\n  for (let i = samples.length - 1; i >= 0; i--) {\r\n    samples[i]  = filter.filter(samples[i]);\r\n  }\r\n  // Resample\r\n  resample_(samples, newSamples, interpolator);\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,SAASA,YAAY,QAAQ,gBAAgB;AAC7C,SAASC,MAAM,QAAQ,WAAW;AAClC,SAASC,cAAc,QAAQ,mBAAmB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,eAAe,GAAG;EACtB,OAAO,EAAE,KAAK;EACd,QAAQ,EAAE,KAAK;EACf,OAAO,EAAE,IAAI;EACb,MAAM,EAAE;AACV,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,iBAAiB,GAAG;EACxB,KAAK,EAAE,EAAE;EACT,KAAK,EAAE;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,MAAMC,WAAW,GAAG;EAClB,KAAK,EAAEH,cAAc;EACrB,KAAK,EAAED;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,QAAQA,CAACC,OAAO,EAAEC,aAAa,EAAEC,UAAU,EAAEC,OAAO,GAAC,IAAI,EAAE;EACzEA,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EACvB;EACA;EACA,IAAIC,IAAI,GAAI,CAACF,UAAU,GAAGD,aAAa,IAAIA,aAAa,GAAI,CAAC;EAC7D;EACA,IAAII,UAAU,GAAG,IAAIC,YAAY,CAACN,OAAO,CAACO,MAAM,GAAIH,IAAK,CAAC;EAC1D;EACAD,OAAO,CAACK,MAAM,GAAGL,OAAO,CAACK,MAAM,IAAI,OAAO;EAC1C;EACA,IAAIC,YAAY,GAAG,IAAIhB,YAAY,CACjCO,OAAO,CAACO,MAAM,EACdF,UAAU,CAACE,MAAM,EACjB;IACEC,MAAM,EAAEL,OAAO,CAACK,MAAM;IACtBE,OAAO,EAAEP,OAAO,CAACO,OAAO,IAAI,CAAC;IAC7BC,cAAc,EAAER,OAAO,CAACQ,cAAc,IAAI,CAAC;IAC3CC,UAAU,EAAET,OAAO,CAACS,UAAU,IAAIC,SAAS;IAC3CC,IAAI,EAAEX,OAAO,CAACW,IAAI,IAAI;EACxB,CAAC,CAAC;EACJ;EACA,IAAIX,OAAO,CAACY,GAAG,KAAKF,SAAS,EAAE;IAC7BV,OAAO,CAACY,GAAG,GAAGnB,eAAe,CAACO,OAAO,CAACK,MAAM,CAAC;EAC/C;EACA,IAAIL,OAAO,CAACY,GAAG,EAAE;IACfZ,OAAO,CAACa,OAAO,GAAGb,OAAO,CAACa,OAAO,IAAI,KAAK;IAC1C,MAAMD,GAAG,GAAGjB,WAAW,CAACK,OAAO,CAACa,OAAO,CAAC;IACxC;IACA,IAAId,UAAU,GAAGD,aAAa,EAAE;MAC9B;MACA,IAAIgB,MAAM,GAAG,IAAIF,GAAG,CAClBZ,OAAO,CAACe,QAAQ,IAAIrB,iBAAiB,CAACM,OAAO,CAACa,OAAO,CAAC,EACtDd,UAAU,EACTD,aAAa,GAAG,CAAE,CAAC;MACtBkB,SAAS,CACPnB,OAAO,EAAEK,UAAU,EAAEI,YAAY,EAAEQ,MAAM,CAAC;MAC9C;IACA,CAAC,MAAM;MACL;MACA,IAAIA,MAAM,GAAG,IAAIF,GAAG,CAClBZ,OAAO,CAACe,QAAQ,IAAIrB,iBAAiB,CAACM,OAAO,CAACa,OAAO,CAAC,EACtDf,aAAa,EACbC,UAAU,GAAG,CAAC,CAAC;MACjBkB,WAAW,CACTpB,OAAO,EAAEK,UAAU,EAAEI,YAAY,EAAEQ,MAAM,CAAC;IAC9C;IACF;EACA,CAAC,MAAM;IACLI,SAAS,CAACrB,OAAO,EAAEK,UAAU,EAAEI,YAAY,CAAC;EAC9C;EACA,OAAOJ,UAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASgB,SAASA,CAACrB,OAAO,EAAEK,UAAU,EAAEI,YAAY,EAAE;EACpD;EACA,KAAK,IAAIa,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGlB,UAAU,CAACE,MAAM,EAAEe,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACrDjB,UAAU,CAACiB,CAAC,CAAC,GAAGb,YAAY,CAACe,WAAW,CAACF,CAAC,EAAEtB,OAAO,CAAC;EACtD;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASmB,SAASA,CAACnB,OAAO,EAAEK,UAAU,EAAEI,YAAY,EAAEQ,MAAM,EAAE;EAC5D;EACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGlB,UAAU,CAACE,MAAM,EAAEe,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IACrDjB,UAAU,CAACiB,CAAC,CAAC,GAAGL,MAAM,CAACA,MAAM,CAACR,YAAY,CAACe,WAAW,CAACF,CAAC,EAAEtB,OAAO,CAAC,CAAC;EACrE;EACA;EACAiB,MAAM,CAACQ,KAAK,CAAC,CAAC;EACd,KAAK,IAAIH,CAAC,GAAGjB,UAAU,CAACE,MAAM,GAAG,CAAC,EAAEe,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC/CjB,UAAU,CAACiB,CAAC,CAAC,GAAIL,MAAM,CAACA,MAAM,CAACZ,UAAU,CAACiB,CAAC,CAAC,CAAC;EAC/C;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASF,WAAWA,CAACpB,OAAO,EAAEK,UAAU,EAAEI,YAAY,EAAEQ,MAAM,EAAE;EAC9D;EACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEC,GAAG,GAAGvB,OAAO,CAACO,MAAM,EAAEe,CAAC,GAAGC,GAAG,EAAED,CAAC,EAAE,EAAE;IAClDtB,OAAO,CAACsB,CAAC,CAAC,GAAIL,MAAM,CAACA,MAAM,CAACjB,OAAO,CAACsB,CAAC,CAAC,CAAC;EACzC;EACA;EACAL,MAAM,CAACQ,KAAK,CAAC,CAAC;EACd,KAAK,IAAIH,CAAC,GAAGtB,OAAO,CAACO,MAAM,GAAG,CAAC,EAAEe,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;IAC5CtB,OAAO,CAACsB,CAAC,CAAC,GAAIL,MAAM,CAACA,MAAM,CAACjB,OAAO,CAACsB,CAAC,CAAC,CAAC;EACzC;EACA;EACAD,SAAS,CAACrB,OAAO,EAAEK,UAAU,EAAEI,YAAY,CAAC;AAC9C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}