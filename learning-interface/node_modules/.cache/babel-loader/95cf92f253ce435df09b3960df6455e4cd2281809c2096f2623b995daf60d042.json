{"ast":null,"code":"/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\n\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\nexport class FloatParser {\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\n  constructor(ebits, fbits) {\n    /**\r\n     * @type {number}\r\n     */\n    this.offset = Math.ceil((ebits + fbits) / 8);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.ebits = ebits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.fbits = fbits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.bias = (1 << ebits - 1) - 1;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.biasP2 = Math.pow(2, this.bias + 1);\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.ebitsFbits = ebits + fbits;\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\n  }\n\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\n  pack(buffer, num, index) {\n    // Round overflows\n    if (Math.abs(num) > this.biasP2 - this.ebitsFbits * 2) {\n      num = num < 0 ? -Infinity : Infinity;\n    }\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\n    let sign = ((num = +num) || 1 / num) < 0 ? 1 : num < 0 ? 1 : 0;\n    num = Math.abs(num);\n    /** @type {number} */\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\n    /** @type {number} */\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));\n    // NaN\n    if (num !== num) {\n      fraction = Math.pow(2, this.fbits - 1);\n      exp = (1 << this.ebits) - 1;\n      // Number\n    } else if (num !== 0) {\n      if (num >= Math.pow(2, 1 - this.bias)) {\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\n          exp = exp + 1;\n          fraction = 1;\n        }\n        // Overflow\n        if (exp > this.bias) {\n          exp = (1 << this.ebits) - 1;\n          fraction = 0;\n        } else {\n          exp = exp + this.bias;\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\n        }\n      } else {\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\n        exp = 0;\n      }\n    }\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\n  }\n\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\n  unpack(buffer, index) {\n    /** @type {number} */\n    let eMax = (1 << this.ebits) - 1;\n    /** @type {number} */\n    let significand;\n    /** @type {string} */\n    let leftBits = \"\";\n    for (let i = this.offset - 1; i >= 0; i--) {\n      /** @type {string} */\n      let t = buffer[i + index].toString(2);\n      leftBits += \"00000000\".substring(t.length) + t;\n    }\n    /** @type {number} */\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\n    leftBits = leftBits.substring(1);\n    /** @type {number} */\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\n    leftBits = leftBits.substring(this.ebits);\n    if (exponent == eMax) {\n      if (parseInt(leftBits, 2) !== 0) {\n        return NaN;\n      }\n      return sign * Infinity;\n    } else if (exponent === 0) {\n      exponent += 1;\n      significand = parseInt(leftBits, 2);\n    } else {\n      significand = parseInt(\"1\" + leftBits, 2);\n    }\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\n  }\n\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\n  packFloatBits_(buffer, index, sign, exp, fraction) {\n    /** @type {!Array<number>} */\n    let bits = [];\n    // the sign\n    bits.push(sign);\n    // the exponent\n    for (let i = this.ebits; i > 0; i -= 1) {\n      bits[i] = exp % 2 ? 1 : 0;\n      exp = Math.floor(exp / 2);\n    }\n    // the fraction\n    let len = bits.length;\n    for (let i = this.fbits; i > 0; i -= 1) {\n      bits[len + i] = fraction % 2 ? 1 : 0;\n      fraction = Math.floor(fraction / 2);\n    }\n    // pack as bytes\n    /** @type {string} */\n    let str = bits.join('');\n    /** @type {number} */\n    let offset = this.offset + index - 1;\n    /** @type {number} */\n    let k = index;\n    while (offset >= index) {\n      buffer[offset] = parseInt(str.substring(0, 8), 2);\n      str = str.substring(8);\n      offset--;\n      k++;\n    }\n    return k;\n  }\n}\n\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\nfunction roundToEven(n) {\n  /** @type {number} */\n  let w = Math.floor(n);\n  let f = n - w;\n  if (f < 0.5) {\n    return w;\n  }\n  if (f > 0.5) {\n    return w + 1;\n  }\n  return w % 2 ? w + 1 : w;\n}","map":{"version":3,"names":["FloatParser","constructor","ebits","fbits","offset","Math","ceil","bias","biasP2","pow","ebitsFbits","fbias","pack","buffer","num","index","abs","Infinity","sign","exp","min","floor","log","LN2","fraction","roundToEven","packFloatBits_","unpack","eMax","significand","leftBits","i","t","toString","substring","length","charAt","exponent","parseInt","NaN","bits","push","len","str","join","k","n","w","f"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/parsers/binary/lib/float-parser.js"],"sourcesContent":["/*\r\n * Copyright (c) 2018-2019 Rafael da Silva Rocha.\r\n * Copyright (c) 2013 DeNA Co., Ltd.\r\n * Copyright (c) 2010, Linden Research, Inc\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode IEEE 754 floating point numbers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n * @see https://bitbucket.org/lindenlab/llsd/raw/7d2646cd3f9b4c806e73aebc4b32bd81e4047fdc/js/typedarray.js\r\n * @see https://github.com/kazuho/ieee754.js/blob/master/ieee754.js\r\n */\r\n\r\n/**\r\n * A class to encode and decode IEEE 754 floating-point numbers.\r\n */\r\nexport class FloatParser {\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {number} ebits The exponent bits.\r\n   * @param {number} fbits The fraction bits.\r\n   */\r\n  constructor(ebits, fbits) {\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil((ebits + fbits) / 8);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebits = ebits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbits = fbits;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.bias = (1 << (ebits - 1)) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.biasP2 = Math.pow(2, this.bias + 1);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.ebitsFbits = (ebits + fbits);\r\n    /**\r\n     * @type {number}\r\n     * @private\r\n     */\r\n    this.fbias = Math.pow(2, -(8 * this.offset - 1 - ebits));\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE 754 floating point number.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} num The number.\r\n   * @param {number} index The index to write on the buffer.\r\n   * @return {number} The next index to write on the buffer.\r\n   */\r\n  pack(buffer, num, index) {\r\n    // Round overflows\r\n    if (Math.abs(num) > this.biasP2 - (this.ebitsFbits * 2)) {\r\n      num = num < 0 ? -Infinity : Infinity;\r\n    }\r\n    /**\r\n     * sign, need this to handle negative zero\r\n     * @see http://cwestblog.com/2014/02/25/javascript-testing-for-negative-zero/\r\n     * @type {number}\r\n     */\r\n    let sign = (((num = +num) || 1 / num) < 0) ? 1 : num < 0 ? 1 : 0;\r\n    num = Math.abs(num);\r\n    /** @type {number} */\r\n    let exp = Math.min(Math.floor(Math.log(num) / Math.LN2), 1023);\r\n    /** @type {number} */\r\n    let fraction = roundToEven(num / Math.pow(2, exp) * Math.pow(2, this.fbits));\r\n    // NaN\r\n    if (num !== num) {\r\n      fraction = Math.pow(2, this.fbits - 1);\r\n      exp = (1 << this.ebits) - 1;\r\n    // Number\r\n    } else if (num !== 0) {\r\n      if (num >= Math.pow(2, 1 - this.bias)) {\r\n        if (fraction / Math.pow(2, this.fbits) >= 2) {\r\n          exp = exp + 1;\r\n          fraction = 1;\r\n        }\r\n        // Overflow\r\n        if (exp > this.bias) {\r\n          exp = (1 << this.ebits) - 1;\r\n          fraction = 0;\r\n        } else {\r\n          exp = exp + this.bias;\r\n          fraction = roundToEven(fraction) - Math.pow(2, this.fbits);\r\n        }\r\n      } else {\r\n        fraction = roundToEven(num / Math.pow(2, 1 - this.bias - this.fbits));\r\n        exp = 0;\r\n      } \r\n    }\r\n    return this.packFloatBits_(buffer, index, sign, exp, fraction);\r\n  }\r\n\r\n  /**\r\n   * Unpack a IEEE 754 floating point number.\r\n   * Derived from IEEE754 by DeNA Co., Ltd., MIT License. \r\n   * Adapted to handle NaN. Should port the solution to the original repo.\r\n   * @param {!Uint8Array|!Array<number>} buffer The buffer.\r\n   * @param {number} index The index to read from the buffer.\r\n   * @return {number} The floating point number.\r\n   */\r\n  unpack(buffer, index) {\r\n    /** @type {number} */\r\n    let eMax = (1 << this.ebits) - 1;\r\n    /** @type {number} */\r\n    let significand;\r\n    /** @type {string} */\r\n    let leftBits = \"\";\r\n    for (let i = this.offset - 1; i >= 0 ; i--) {\r\n      /** @type {string} */\r\n      let t = buffer[i + index].toString(2);\r\n      leftBits += \"00000000\".substring(t.length) + t;\r\n    }\r\n    /** @type {number} */\r\n    let sign = leftBits.charAt(0) == \"1\" ? -1 : 1;\r\n    leftBits = leftBits.substring(1);\r\n    /** @type {number} */\r\n    let exponent = parseInt(leftBits.substring(0, this.ebits), 2);\r\n    leftBits = leftBits.substring(this.ebits);\r\n    if (exponent == eMax) {\r\n      if (parseInt(leftBits, 2) !== 0) {\r\n        return NaN;\r\n      }\r\n      return sign * Infinity;  \r\n    } else if (exponent === 0) {\r\n      exponent += 1;\r\n      significand = parseInt(leftBits, 2);\r\n    } else {\r\n      significand = parseInt(\"1\" + leftBits, 2);\r\n    }\r\n    return sign * significand * this.fbias * Math.pow(2, exponent - this.bias);\r\n  }\r\n\r\n  /**\r\n   * Pack a IEEE754 from its sign, exponent and fraction bits\r\n   * and place it in a byte buffer.\r\n   * @param {!Uint8Array|!Array<number>} buffer The byte buffer to write to.\r\n   * @param {number} index The buffer index to write.\r\n   * @param {number} sign The sign.\r\n   * @param {number} exp the exponent.\r\n   * @param {number} fraction The fraction.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  packFloatBits_(buffer, index, sign, exp, fraction) {\r\n    /** @type {!Array<number>} */\r\n    let bits = [];\r\n    // the sign\r\n    bits.push(sign);\r\n    // the exponent\r\n    for (let i = this.ebits; i > 0; i -= 1) {\r\n      bits[i] = (exp % 2 ? 1 : 0);\r\n      exp = Math.floor(exp / 2);\r\n    }\r\n    // the fraction\r\n    let len = bits.length;\r\n    for (let i = this.fbits; i > 0; i -= 1) {\r\n      bits[len + i] = (fraction % 2 ? 1 : 0);\r\n      fraction = Math.floor(fraction / 2);\r\n    }\r\n    // pack as bytes\r\n    /** @type {string} */\r\n    let str = bits.join('');\r\n    /** @type {number} */\r\n    let offset = this.offset + index - 1;\r\n    /** @type {number} */\r\n    let k = index;\r\n    while (offset >= index) {\r\n      buffer[offset] = parseInt(str.substring(0, 8), 2);\r\n      str = str.substring(8);\r\n      offset--;\r\n      k++;\r\n    }\r\n    return k;\r\n  }\r\n}\r\n\r\n/**\r\n * Round a number to its nearest even value.\r\n * @param {number} n The number.\r\n * @return {number}\r\n * @private\r\n */\r\nfunction roundToEven(n) {\r\n  /** @type {number} */\r\n  let w = Math.floor(n);\r\n  let f = n - w;\r\n  if (f < 0.5) {\r\n    return w;\r\n  }\r\n  if (f > 0.5) {\r\n    return w + 1;\r\n  }\r\n  return w % 2 ? w + 1 : w;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}