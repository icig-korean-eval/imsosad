{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\n\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\nexport class IntParser {\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\n  constructor(bits, signed = false) {\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\n    this.bits = bits;\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\n    this.offset = Math.ceil(bits / 8);\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n    this.max = Math.pow(2, bits) - 1;\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n    this.min = 0;\n    /**\r\n     * @type {Function}\r\n     */\n    this.unpack = this.unpack_;\n    if (signed) {\n      this.max = Math.pow(2, bits) / 2 - 1;\n      this.min = -this.max - 1;\n      this.unpack = this.unpackSigned_;\n    }\n  }\n\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\n  pack(buffer, num, index = 0) {\n    num = this.clamp_(Math.round(num));\n    for (let i = 0, len = this.offset; i < len; i++) {\n      buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\n      index++;\n    }\n    return index;\n  }\n\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\n  unpack_(buffer, index = 0) {\n    /** @type {number} */\n    let num = 0;\n    for (let x = 0; x < this.offset; x++) {\n      num += buffer[index + x] * Math.pow(256, x);\n    }\n    return num;\n  }\n\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\n  unpackSigned_(buffer, index = 0) {\n    return this.sign_(this.unpack_(buffer, index));\n  }\n\n  /**\r\n   * Clamp values on overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\n  clamp_(num) {\n    if (num > this.max) {\n      return this.max;\n    } else if (num < this.min) {\n      return this.min;\n    }\n    return num;\n  }\n\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\n  sign_(num) {\n    if (num > this.max) {\n      num -= this.max * 2 + 2;\n    }\n    return num;\n  }\n}","map":{"version":3,"names":["IntParser","constructor","bits","signed","offset","Math","ceil","max","pow","min","unpack","unpack_","unpackSigned_","pack","buffer","num","index","clamp_","round","i","len","floor","x","sign_"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/parsers/binary/lib/int-parser.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2018 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview Encode and decode int numbers to and from byte buffers.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\n/**\r\n * A class to write and read integer numbers to and from byte buffers.\r\n */\r\nexport class IntParser {\r\n  \r\n  /**\r\n   * @param {number} bits The number of bits used by the integer.\r\n   * @param {boolean} [signed=false] True for signed, false otherwise.\r\n   */\r\n  constructor(bits, signed=false) {\r\n    /**\r\n     * The number of bits used by one number.\r\n     * @type {number}\r\n     */\r\n    this.bits = bits;\r\n    /**\r\n     * The number of bytes used by one number.\r\n     * @type {number}\r\n     */\r\n    this.offset = Math.ceil(bits / 8);\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.max = Math.pow(2, bits) - 1;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.min = 0;\r\n    /**\r\n     * @type {Function}\r\n     */\r\n    this.unpack = this.unpack_;\r\n    if (signed) {\r\n      this.max = Math.pow(2, bits) / 2 - 1;\r\n      this.min = -this.max - 1;\r\n      this.unpack = this.unpackSigned_;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Write one unsigned integer to a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} num The number. Overflows are truncated.\r\n   * @param {number} [index=0] The index being written in the byte buffer.\r\n   * @return {number} The next index to write on the byte buffer.\r\n   */\r\n  pack(buffer, num, index=0) {\r\n    num = this.clamp_(Math.round(num));\r\n    for (let i = 0, len = this.offset; i < len; i++) {\r\n      buffer[index] = Math.floor(num / Math.pow(2, i * 8)) & 255;\r\n      index++;\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Read one unsigned integer from a byte buffer.\r\n   * Does not check for overflows.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpack_(buffer, index=0) {\r\n    /** @type {number} */\r\n    let num = 0;\r\n    for(let x = 0; x < this.offset; x++) {\r\n      num += buffer[index + x] * Math.pow(256, x);\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Read one two's complement signed integer from a byte buffer.\r\n   * @param {!(Uint8Array|Array<number>)} buffer An array of bytes.\r\n   * @param {number} [index=0] The index to read.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  unpackSigned_(buffer, index=0) {\r\n    return this.sign_(this.unpack_(buffer, index));\r\n  }\r\n\r\n  /**\r\n   * Clamp values on overflow.\r\n   * @param {number} num The number.\r\n   * @private\r\n   */\r\n  clamp_(num) {\r\n    if (num > this.max) {\r\n      return this.max;\r\n    } else if (num < this.min) {\r\n      return this.min;\r\n    }\r\n    return num;\r\n  }\r\n\r\n  /**\r\n   * Sign a number.\r\n   * @param {number} num The number.\r\n   * @return {number}\r\n   * @private\r\n   */\r\n  sign_(num) {\r\n    if (num > this.max) {\r\n      num -= (this.max * 2) + 2;\r\n    }\r\n    return num;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}