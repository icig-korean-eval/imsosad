{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { WaveFileParser } from './wavefile-parser';\nimport { interleave, deInterleave } from './parsers/interleave';\nimport { validateNumChannels } from './validators/validate-num-channels';\nimport { validateSampleRate } from './validators/validate-sample-rate';\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\n\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\nexport class WaveFileCreator extends WaveFileParser {\n  constructor() {\n    super();\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\n    this.bitDepth = '0';\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\n    this.dataType = {\n      bits: 0,\n      be: false\n    };\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\n    this.WAV_AUDIO_FORMATS = {\n      '4': 17,\n      '8': 1,\n      '8a': 6,\n      '8m': 7,\n      '16': 1,\n      '24': 1,\n      '32': 1,\n      '32f': 3,\n      '64': 3\n    };\n  }\n\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\n  fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\n    options = options || {};\n    // reset all chunks\n    this.clearHeaders();\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\n  }\n\n  /**\r\n   * Set up the WaveFileParser object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\n  fromBuffer(wavBuffer, samples = true) {\n    super.fromBuffer(wavBuffer, samples);\n    this.bitDepthFromFmt_();\n    this.updateDataType_();\n  }\n\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   */\n  toBuffer() {\n    this.validateWavHeader_();\n    return super.toBuffer();\n  }\n\n  /**\r\n   * Return the samples packed in a Float64Array.\r\n   * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n   *   false to return the samples de-interleaved.\r\n   * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n   * @return {!(Array|TypedArray)} the samples.\r\n   */\n  getSamples(interleaved = false, OutputObject = Float64Array) {\n    /**\r\n     * A Float64Array created with a size to match the\r\n     * the length of the samples.\r\n     * @type {!(Array|TypedArray)}\r\n     */\n    let samples = new OutputObject(this.data.samples.length / (this.dataType.bits / 8));\n    // Unpack all the samples\n    unpackArrayTo(this.data.samples, this.dataType, samples, 0, this.data.samples.length);\n    if (!interleaved && this.fmt.numChannels > 1) {\n      return deInterleave(samples, this.fmt.numChannels, OutputObject);\n    }\n    return samples;\n  }\n\n  /**\r\n   * Return the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @return {number} The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\n  getSample(index) {\n    index = index * (this.dataType.bits / 8);\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\n      throw new Error('Range error');\n    }\n    return unpack(this.data.samples.slice(index, index + this.dataType.bits / 8), this.dataType);\n  }\n\n  /**\r\n   * Set the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @param {number} sample The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\n  setSample(index, sample) {\n    index = index * (this.dataType.bits / 8);\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\n      throw new Error('Range error');\n    }\n    packTo(sample, this.dataType, this.data.samples, index, true);\n  }\n\n  /**\r\n   * Return the value of the iXML chunk.\r\n   * @return {string} The contents of the iXML chunk.\r\n   */\n  getiXML() {\n    return this.iXML.value;\n  }\n\n  /**\r\n   * Set the value of the iXML chunk.\r\n   * @param {string} iXMLValue The value for the iXML chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\n  setiXML(iXMLValue) {\n    if (typeof iXMLValue !== 'string') {\n      throw new TypeError('iXML value must be a string.');\n    }\n    this.iXML.value = iXMLValue;\n    this.iXML.chunkId = 'iXML';\n  }\n\n  /**\r\n   * Get the value of the _PMX chunk.\r\n   * @return {string} The contents of the _PMX chunk.\r\n   */\n  get_PMX() {\n    return this._PMX.value;\n  }\n\n  /**\r\n   * Set the value of the _PMX chunk.\r\n   * @param {string} _PMXValue The value for the _PMX chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\n  set_PMX(_PMXValue) {\n    if (typeof _PMXValue !== 'string') {\n      throw new TypeError('_PMX value must be a string.');\n    }\n    this._PMX.value = _PMXValue;\n    this._PMX.chunkId = '_PMX';\n  }\n\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *   or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object} options Used to define the container.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\n  newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\n    if (!options.container) {\n      options.container = 'RIFF';\n    }\n    this.container = options.container;\n    this.bitDepth = bitDepthCode;\n    samples = interleave(samples);\n    this.updateDataType_();\n    /** @type {number} */\n    let numBytes = this.dataType.bits / 8;\n    this.data.samples = new Uint8Array(samples.length * numBytes);\n    packArrayTo(samples, this.dataType, this.data.samples, 0, true);\n    this.makeWavHeader_(bitDepthCode, numChannels, sampleRate, numBytes, this.data.samples.length, options);\n    this.data.chunkId = 'data';\n    this.data.chunkSize = this.data.samples.length;\n    this.validateWavHeader_();\n  }\n\n  /**\r\n   * Define the header of a wav file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n  makeWavHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    if (bitDepthCode == '4') {\n      this.createADPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\n      this.createALawMulawHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    } else if (Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 || numChannels > 2) {\n      this.createExtensibleHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    } else {\n      this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    }\n  }\n\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n  createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.container = options.container;\n    this.chunkSize = 36 + samplesLength;\n    this.format = 'WAVE';\n    this.bitDepth = bitDepthCode;\n    this.fmt = {\n      chunkId: 'fmt ',\n      chunkSize: 16,\n      audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\n      numChannels: numChannels,\n      sampleRate: sampleRate,\n      byteRate: numChannels * numBytes * sampleRate,\n      blockAlign: numChannels * numBytes,\n      bitsPerSample: parseInt(bitDepthCode, 10),\n      cbSize: 0,\n      validBitsPerSample: 0,\n      dwChannelMask: 0,\n      subformat: []\n    };\n  }\n\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n  createADPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    this.chunkSize = 40 + samplesLength;\n    this.fmt.chunkSize = 20;\n    this.fmt.byteRate = 4055;\n    this.fmt.blockAlign = 256;\n    this.fmt.bitsPerSample = 4;\n    this.fmt.cbSize = 2;\n    this.fmt.validBitsPerSample = 505;\n    this.fact = {\n      chunkId: 'fact',\n      chunkSize: 4,\n      dwSampleLength: samplesLength * 2\n    };\n  }\n\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n  createExtensibleHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    this.chunkSize = 36 + 24 + samplesLength;\n    this.fmt.chunkSize = 40;\n    this.fmt.bitsPerSample = (parseInt(bitDepthCode, 10) - 1 | 7) + 1;\n    this.fmt.cbSize = 22;\n    this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\n    this.fmt.dwChannelMask = dwChannelMask_(numChannels);\n    // subformat 128-bit GUID as 4 32-bit values\n    // only supports uncompressed integer PCM samples\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\n  }\n\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\n  createALawMulawHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\n    this.createPCMHeader_(bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\n    this.chunkSize = 40 + samplesLength;\n    this.fmt.chunkSize = 20;\n    this.fmt.cbSize = 2;\n    this.fmt.validBitsPerSample = 8;\n    this.fact = {\n      chunkId: 'fact',\n      chunkSize: 4,\n      dwSampleLength: samplesLength\n    };\n  }\n\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\n  bitDepthFromFmt_() {\n    if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\n      this.bitDepth = '32f';\n    } else if (this.fmt.audioFormat === 6) {\n      this.bitDepth = '8a';\n    } else if (this.fmt.audioFormat === 7) {\n      this.bitDepth = '8m';\n    } else {\n      this.bitDepth = this.fmt.bitsPerSample.toString();\n    }\n  }\n\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\n  validateBitDepth_() {\n    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\n      if (parseInt(this.bitDepth, 10) > 8 && parseInt(this.bitDepth, 10) < 54) {\n        return true;\n      }\n      throw new Error('Invalid bit depth.');\n    }\n    return true;\n  }\n\n  /**\r\n   * Update the type definition used to read and write the samples.\r\n   * @private\r\n   */\n  updateDataType_() {\n    this.dataType = {\n      bits: (parseInt(this.bitDepth, 10) - 1 | 7) + 1,\n      fp: this.bitDepth == '32f' || this.bitDepth == '64',\n      signed: this.bitDepth != '8',\n      be: this.container == 'RIFX'\n    };\n    if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1) {\n      this.dataType.bits = 8;\n      this.dataType.signed = false;\n    }\n  }\n\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @ignore\r\n   * @private\r\n   */\n  validateWavHeader_() {\n    this.validateBitDepth_();\n    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\n      throw new Error('Invalid number of channels.');\n    }\n    if (!validateSampleRate(this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\n      throw new Error('Invalid sample rate.');\n    }\n  }\n}\n\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\nfunction dwChannelMask_(numChannels) {\n  /** @type {number} */\n  let mask = 0;\n  // mono = FC\n  if (numChannels === 1) {\n    mask = 0x4;\n    // stereo = FL, FR\n  } else if (numChannels === 2) {\n    mask = 0x3;\n    // quad = FL, FR, BL, BR\n  } else if (numChannels === 4) {\n    mask = 0x33;\n    // 5.1 = FL, FR, FC, LF, BL, BR\n  } else if (numChannels === 6) {\n    mask = 0x3F;\n    // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\n  } else if (numChannels === 8) {\n    mask = 0x63F;\n  }\n  return mask;\n}","map":{"version":3,"names":["WaveFileParser","interleave","deInterleave","validateNumChannels","validateSampleRate","packArrayTo","unpackArrayTo","packTo","unpack","WaveFileCreator","constructor","bitDepth","dataType","bits","be","WAV_AUDIO_FORMATS","fromScratch","numChannels","sampleRate","bitDepthCode","samples","options","clearHeaders","newWavFile_","fromBuffer","wavBuffer","bitDepthFromFmt_","updateDataType_","toBuffer","validateWavHeader_","getSamples","interleaved","OutputObject","Float64Array","data","length","fmt","getSample","index","Error","slice","setSample","sample","getiXML","iXML","value","setiXML","iXMLValue","TypeError","chunkId","get_PMX","_PMX","set_PMX","_PMXValue","container","numBytes","Uint8Array","makeWavHeader_","chunkSize","samplesLength","createADPCMHeader_","createALawMulawHeader_","Object","keys","indexOf","createExtensibleHeader_","createPCMHeader_","format","audioFormat","byteRate","blockAlign","bitsPerSample","parseInt","cbSize","validBitsPerSample","dwChannelMask","subformat","fact","dwSampleLength","dwChannelMask_","toString","validateBitDepth_","fp","signed","mask"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/wavefile-creator.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileCreator class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { WaveFileParser } from './wavefile-parser';\r\nimport { interleave, deInterleave } from './parsers/interleave';\r\nimport { validateNumChannels } from './validators/validate-num-channels'; \r\nimport { validateSampleRate } from './validators/validate-sample-rate';\r\nimport { packArrayTo, unpackArrayTo, packTo, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read, write and create wav files.\r\n * @extends WaveFileParser\r\n * @ignore\r\n */\r\nexport class WaveFileCreator extends WaveFileParser {\r\n\r\n  constructor() {\r\n    super();\r\n    /**\r\n     * The bit depth code according to the samples.\r\n     * @type {string}\r\n     */\r\n    this.bitDepth = '0';\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.dataType = {bits: 0, be: false};\r\n    /**\r\n     * Audio formats.\r\n     * Formats not listed here should be set to 65534,\r\n     * the code for WAVE_FORMAT_EXTENSIBLE\r\n     * @enum {number}\r\n     * @protected\r\n     */\r\n    this.WAV_AUDIO_FORMATS = {\r\n      '4': 17,\r\n      '8': 1,\r\n      '8a': 6,\r\n      '8m': 7,\r\n      '16': 1,\r\n      '24': 1,\r\n      '32': 1,\r\n      '32f': 3,\r\n      '64': 3\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * Existing chunks are reset.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *    Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *    One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *    or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object=} options Optional. Used to force the container\r\n   *    as RIFX with {'container': 'RIFX'}\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   */\r\n  fromScratch(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    options = options || {};\r\n    // reset all chunks\r\n    this.clearHeaders();\r\n    this.newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options);\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileParser object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    super.fromBuffer(wavBuffer, samples);\r\n    this.bitDepthFromFmt_();\r\n    this.updateDataType_();\r\n  }\r\n\r\n  /**\r\n   * Return a byte buffer representig the WaveFileParser object as a .wav file.\r\n   * The return value of this method can be written straight to disk.\r\n   * @return {!Uint8Array} A wav file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   */\r\n  toBuffer() {\r\n    this.validateWavHeader_();\r\n    return super.toBuffer();\r\n  }\r\n\r\n  /**\r\n   * Return the samples packed in a Float64Array.\r\n   * @param {boolean=} [interleaved=false] True to return interleaved samples,\r\n   *   false to return the samples de-interleaved.\r\n   * @param {Function=} [OutputObject=Float64Array] The sample container.\r\n   * @return {!(Array|TypedArray)} the samples.\r\n   */\r\n  getSamples(interleaved=false, OutputObject=Float64Array) {\r\n    /**\r\n     * A Float64Array created with a size to match the\r\n     * the length of the samples.\r\n     * @type {!(Array|TypedArray)}\r\n     */\r\n    let samples = new OutputObject(\r\n      this.data.samples.length / (this.dataType.bits / 8));\r\n    // Unpack all the samples\r\n    unpackArrayTo(this.data.samples, this.dataType, samples,\r\n      0, this.data.samples.length);\r\n    if (!interleaved && this.fmt.numChannels > 1) {\r\n      return deInterleave(samples, this.fmt.numChannels, OutputObject);\r\n    }\r\n    return samples;\r\n  }\r\n\r\n  /**\r\n   * Return the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @return {number} The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  getSample(index) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    return unpack(\r\n      this.data.samples.slice(index, index + this.dataType.bits / 8),\r\n      this.dataType);\r\n  }\r\n\r\n  /**\r\n   * Set the sample at a given index.\r\n   * @param {number} index The sample index.\r\n   * @param {number} sample The sample.\r\n   * @throws {Error} If the sample index is off range.\r\n   */\r\n  setSample(index, sample) {\r\n    index = index * (this.dataType.bits / 8);\r\n    if (index + this.dataType.bits / 8 > this.data.samples.length) {\r\n      throw new Error('Range error');\r\n    }\r\n    packTo(sample, this.dataType, this.data.samples, index, true);\r\n  }\r\n\r\n  /**\r\n   * Return the value of the iXML chunk.\r\n   * @return {string} The contents of the iXML chunk.\r\n   */\r\n  getiXML() {\r\n    return this.iXML.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the iXML chunk.\r\n   * @param {string} iXMLValue The value for the iXML chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  setiXML(iXMLValue) {\r\n    if (typeof iXMLValue !== 'string') {\r\n      throw new TypeError('iXML value must be a string.');\r\n    }\r\n    this.iXML.value = iXMLValue;\r\n    this.iXML.chunkId = 'iXML';\r\n  }\r\n\r\n  /**\r\n   * Get the value of the _PMX chunk.\r\n   * @return {string} The contents of the _PMX chunk.\r\n   */\r\n  get_PMX() {\r\n    return this._PMX.value;\r\n  }\r\n\r\n  /**\r\n   * Set the value of the _PMX chunk.\r\n   * @param {string} _PMXValue The value for the _PMX chunk.\r\n   * @throws {TypeError} If the value is not a string.\r\n   */\r\n  set_PMX(_PMXValue) {\r\n    if (typeof _PMXValue !== 'string') {\r\n      throw new TypeError('_PMX value must be a string.');\r\n    }\r\n    this._PMX.value = _PMXValue;\r\n    this._PMX.chunkId = '_PMX';\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileCreator object based on the arguments passed.\r\n   * @param {number} numChannels The number of channels.\r\n   * @param {number} sampleRate The sample rate.\r\n   *   Integers like 8000, 44100, 48000, 96000, 192000.\r\n   * @param {string} bitDepthCode The audio bit depth code.\r\n   *   One of '4', '8', '8a', '8m', '16', '24', '32', '32f', '64'\r\n   *   or any value between '8' and '32' (like '12').\r\n   * @param {!(Array|TypedArray)} samples The samples.\r\n   * @param {Object} options Used to define the container.\r\n   * @throws {Error} If any argument does not meet the criteria.\r\n   * @private\r\n   */\r\n  newWavFile_(numChannels, sampleRate, bitDepthCode, samples, options) {\r\n    if (!options.container) {\r\n      options.container = 'RIFF';\r\n    }\r\n    this.container = options.container;\r\n    this.bitDepth = bitDepthCode;\r\n    samples = interleave(samples);\r\n    this.updateDataType_();\r\n    /** @type {number} */\r\n    let numBytes = this.dataType.bits / 8;\r\n    this.data.samples = new Uint8Array(samples.length * numBytes);\r\n    packArrayTo(samples, this.dataType, this.data.samples, 0, true);\r\n    this.makeWavHeader_(\r\n      bitDepthCode, numChannels, sampleRate,\r\n      numBytes, this.data.samples.length, options);\r\n    this.data.chunkId = 'data';\r\n    this.data.chunkSize = this.data.samples.length;\r\n    this.validateWavHeader_();\r\n  }\r\n\r\n  /**\r\n   * Define the header of a wav file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  makeWavHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    if (bitDepthCode == '4') {\r\n      this.createADPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if (bitDepthCode == '8a' || bitDepthCode == '8m') {\r\n      this.createALawMulawHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else if(Object.keys(this.WAV_AUDIO_FORMATS).indexOf(bitDepthCode) == -1 ||\r\n        numChannels > 2) {\r\n      this.createExtensibleHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n\r\n    } else {\r\n      this.createPCMHeader_(\r\n        bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);      \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create the header of a linear PCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.container = options.container;\r\n    this.chunkSize = 36 + samplesLength;\r\n    this.format = 'WAVE';\r\n    this.bitDepth = bitDepthCode;\r\n    this.fmt = {\r\n      chunkId: 'fmt ',\r\n      chunkSize: 16,\r\n      audioFormat: this.WAV_AUDIO_FORMATS[bitDepthCode] || 65534,\r\n      numChannels: numChannels,\r\n      sampleRate: sampleRate,\r\n      byteRate: (numChannels * numBytes) * sampleRate,\r\n      blockAlign: numChannels * numBytes,\r\n      bitsPerSample: parseInt(bitDepthCode, 10),\r\n      cbSize: 0,\r\n      validBitsPerSample: 0,\r\n      dwChannelMask: 0,\r\n      subformat: []\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of a ADPCM wave file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createADPCMHeader_(\r\n    bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.byteRate = 4055;\r\n    this.fmt.blockAlign = 256;\r\n    this.fmt.bitsPerSample = 4;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 505;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength * 2\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create the header of WAVE_FORMAT_EXTENSIBLE file.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createExtensibleHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 36 + 24 + samplesLength;\r\n    this.fmt.chunkSize = 40;\r\n    this.fmt.bitsPerSample = ((parseInt(bitDepthCode, 10) - 1) | 7) + 1;\r\n    this.fmt.cbSize = 22;\r\n    this.fmt.validBitsPerSample = parseInt(bitDepthCode, 10);\r\n    this.fmt.dwChannelMask = dwChannelMask_(numChannels);\r\n    // subformat 128-bit GUID as 4 32-bit values\r\n    // only supports uncompressed integer PCM samples\r\n    this.fmt.subformat = [1, 1048576, 2852126848, 1905997824];\r\n  }\r\n\r\n  /**\r\n   * Create the header of mu-Law and A-Law wave files.\r\n   * @param {string} bitDepthCode The audio bit depth\r\n   * @param {number} numChannels The number of channels\r\n   * @param {number} sampleRate The sample rate.\r\n   * @param {number} numBytes The number of bytes each sample use.\r\n   * @param {number} samplesLength The length of the samples in bytes.\r\n   * @param {!Object} options The extra options, like container defintion.\r\n   * @private\r\n   */\r\n  createALawMulawHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options) {\r\n    this.createPCMHeader_(\r\n      bitDepthCode, numChannels, sampleRate, numBytes, samplesLength, options);\r\n    this.chunkSize = 40 + samplesLength;\r\n    this.fmt.chunkSize = 20;\r\n    this.fmt.cbSize = 2;\r\n    this.fmt.validBitsPerSample = 8;\r\n    this.fact = {\r\n      chunkId: 'fact',\r\n      chunkSize: 4,\r\n      dwSampleLength: samplesLength\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Set the string code of the bit depth based on the 'fmt ' chunk.\r\n   * @private\r\n   */\r\n  bitDepthFromFmt_() {\r\n    if (this.fmt.audioFormat === 3 && this.fmt.bitsPerSample === 32) {\r\n      this.bitDepth = '32f';\r\n    } else if (this.fmt.audioFormat === 6) {\r\n      this.bitDepth = '8a';\r\n    } else if (this.fmt.audioFormat === 7) {\r\n      this.bitDepth = '8m';\r\n    } else {\r\n      this.bitDepth = this.fmt.bitsPerSample.toString();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the bit depth.\r\n   * @return {boolean} True is the bit depth is valid.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @private\r\n   */\r\n  validateBitDepth_() {\r\n    if (!this.WAV_AUDIO_FORMATS[this.bitDepth]) {\r\n      if (parseInt(this.bitDepth, 10) > 8 &&\r\n          parseInt(this.bitDepth, 10) < 54) {\r\n        return true;\r\n      }\r\n      throw new Error('Invalid bit depth.');\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Update the type definition used to read and write the samples.\r\n   * @private\r\n   */\r\n  updateDataType_() {\r\n    this.dataType = {\r\n      bits: ((parseInt(this.bitDepth, 10) - 1) | 7) + 1,\r\n      fp: this.bitDepth == '32f' || this.bitDepth == '64',\r\n      signed: this.bitDepth != '8',\r\n      be: this.container == 'RIFX'\r\n    };\r\n    if (['4', '8a', '8m'].indexOf(this.bitDepth) > -1 ) {\r\n      this.dataType.bits = 8;\r\n      this.dataType.signed = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Validate the header of the file.\r\n   * @throws {Error} If bit depth is invalid.\r\n   * @throws {Error} If the number of channels is invalid.\r\n   * @throws {Error} If the sample rate is invalid.\r\n   * @ignore\r\n   * @private\r\n   */\r\n  validateWavHeader_() {\r\n    this.validateBitDepth_();\r\n    if (!validateNumChannels(this.fmt.numChannels, this.fmt.bitsPerSample)) {\r\n      throw new Error('Invalid number of channels.');\r\n    }\r\n    if (!validateSampleRate(\r\n        this.fmt.numChannels, this.fmt.bitsPerSample, this.fmt.sampleRate)) {\r\n      throw new Error('Invalid sample rate.');\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Return the value for dwChannelMask according to the number of channels.\r\n * @param {number} numChannels the number of channels.\r\n * @return {number} the dwChannelMask value.\r\n * @private\r\n */\r\nfunction dwChannelMask_(numChannels) {\r\n  /** @type {number} */\r\n  let mask = 0;\r\n  // mono = FC\r\n  if (numChannels === 1) {\r\n    mask = 0x4;\r\n  // stereo = FL, FR\r\n  } else if (numChannels === 2) {\r\n    mask = 0x3;\r\n  // quad = FL, FR, BL, BR\r\n  } else if (numChannels === 4) {\r\n    mask = 0x33;\r\n  // 5.1 = FL, FR, FC, LF, BL, BR\r\n  } else if (numChannels === 6) {\r\n    mask = 0x3F;\r\n  // 7.1 = FL, FR, FC, LF, BL, BR, SL, SR\r\n  } else if (numChannels === 8) {\r\n    mask = 0x63F;\r\n  }\r\n  return mask;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}