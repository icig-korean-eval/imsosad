{"ast":null,"code":"// src/services/audioService.ts\nimport axios from 'axios';\nimport { AUTH_TOKEN } from '../config/token';\nimport { WaveFile } from 'wavefile';\nexport const requestMicrophoneAccess = async () => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({\n      audio: true\n    });\n    return stream;\n  } catch (error) {\n    console.error('Error accessing microphone:', error);\n    throw error;\n  }\n};\nexport class AudioRecorder {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioChunks = [];\n    this.stream = null;\n  }\n  async startRecording() {\n    this.stream = await requestMicrophoneAccess();\n    this.mediaRecorder = new MediaRecorder(this.stream);\n    this.audioChunks = [];\n    this.mediaRecorder.addEventListener('dataavailable', event => {\n      if (event.data.size > 0) {\n        this.audioChunks.push(event.data);\n      }\n    });\n    this.mediaRecorder.start();\n  }\n  stopRecording() {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder) return reject(new Error('No recording in progress'));\n      this.mediaRecorder.addEventListener('stop', () => {\n        const audioBlob = new Blob(this.audioChunks, {\n          type: 'audio/webm'\n        });\n        this.stopStream();\n        resolve(audioBlob);\n      });\n      this.mediaRecorder.stop();\n    });\n  }\n  stopStream() {\n    if (this.stream) {\n      this.stream.getTracks().forEach(track => track.stop());\n      this.stream = null;\n    }\n  }\n  static createAudioURL(blob) {\n    return URL.createObjectURL(blob);\n  }\n  static revokeAudioURL(url) {\n    URL.revokeObjectURL(url);\n  }\n  static textToSpeech(text, lang = 'ko-KR') {\n    const utterance = new SpeechSynthesisUtterance(text);\n    utterance.lang = lang;\n    return utterance;\n  }\n  static isKoreanText(text) {\n    return !!text.match(/[ㄱ-ㅣ|가-힣]/);\n  }\n}\nconst api = axios.create({\n  baseURL: 'http://175.212.190.95:8010',\n  headers: {\n    Authorization: AUTH_TOKEN\n  }\n});\nexport const transcribeAudio = async blob => {\n  const arrayBuffer = await blob.arrayBuffer();\n  const uint8Array = new Uint8Array(arrayBuffer);\n  const wav = new WaveFile();\n  wav.fromScratch(1, 48000, '16', uint8Array);\n  const wavBlob = new Blob([wav.toBuffer()], {\n    type: 'audio/wav'\n  });\n  const formData = new FormData();\n  formData.append('file', new File([wavBlob], 'voice.wav', {\n    type: 'audio/wav'\n  }));\n  const res = await api.post('/api/v1/transcribe', formData);\n  return res.data.transcription;\n};","map":{"version":3,"names":["axios","AUTH_TOKEN","WaveFile","requestMicrophoneAccess","stream","navigator","mediaDevices","getUserMedia","audio","error","console","AudioRecorder","constructor","mediaRecorder","audioChunks","startRecording","MediaRecorder","addEventListener","event","data","size","push","start","stopRecording","Promise","resolve","reject","Error","audioBlob","Blob","type","stopStream","stop","getTracks","forEach","track","createAudioURL","blob","URL","createObjectURL","revokeAudioURL","url","revokeObjectURL","textToSpeech","text","lang","utterance","SpeechSynthesisUtterance","isKoreanText","match","api","create","baseURL","headers","Authorization","transcribeAudio","arrayBuffer","uint8Array","Uint8Array","wav","fromScratch","wavBlob","toBuffer","formData","FormData","append","File","res","post","transcription"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/src/services/audioService.ts"],"sourcesContent":["// src/services/audioService.ts\nimport axios from 'axios';\nimport { AUTH_TOKEN } from '../config/token';\nimport { WaveFile } from 'wavefile';\n\nexport interface RecordingState {\n  isRecording: boolean;\n  audioURL: string | null;\n}\n\nexport const requestMicrophoneAccess = async (): Promise<MediaStream> => {\n  try {\n    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n    return stream;\n  } catch (error) {\n    console.error('Error accessing microphone:', error);\n    throw error;\n  }\n};\n\nexport class AudioRecorder {\n  private mediaRecorder: MediaRecorder | null = null;\n  private audioChunks: Blob[] = [];\n  private stream: MediaStream | null = null;\n\n  public async startRecording(): Promise<void> {\n    this.stream = await requestMicrophoneAccess();\n    this.mediaRecorder = new MediaRecorder(this.stream);\n    this.audioChunks = [];\n\n    this.mediaRecorder.addEventListener('dataavailable', (event) => {\n      if (event.data.size > 0) {\n        this.audioChunks.push(event.data);\n      }\n    });\n\n    this.mediaRecorder.start();\n  }\n\n  public stopRecording(): Promise<Blob> {\n    return new Promise((resolve, reject) => {\n      if (!this.mediaRecorder) return reject(new Error('No recording in progress'));\n\n      this.mediaRecorder.addEventListener('stop', () => {\n        const audioBlob = new Blob(this.audioChunks, { type: 'audio/webm' });\n        this.stopStream();\n        resolve(audioBlob);\n      });\n\n      this.mediaRecorder.stop();\n    });\n  }\n\n  private stopStream(): void {\n    if (this.stream) {\n      this.stream.getTracks().forEach((track) => track.stop());\n      this.stream = null;\n    }\n  }\n\n  public static createAudioURL(blob: Blob): string {\n    return URL.createObjectURL(blob);\n  }\n\n  public static revokeAudioURL(url: string): void {\n    URL.revokeObjectURL(url);\n  }\n\n  public static textToSpeech(text: string, lang: string = 'ko-KR'): SpeechSynthesisUtterance {\n    const utterance = new SpeechSynthesisUtterance(text);\n    utterance.lang = lang;\n    return utterance;\n  }\n\n  public static isKoreanText(text: string): boolean {\n    return !!text.match(/[ㄱ-ㅣ|가-힣]/);\n  }\n}\n\nconst api = axios.create({\n  baseURL: 'http://175.212.190.95:8010',\n  headers: {\n    Authorization: AUTH_TOKEN,\n  },\n});\n\nexport const transcribeAudio = async (blob: Blob): Promise<string> => {\n  const arrayBuffer = await blob.arrayBuffer();\n  const uint8Array = new Uint8Array(arrayBuffer);\n\n  const wav = new WaveFile();\n  wav.fromScratch(1, 48000, '16', uint8Array);\n  const wavBlob = new Blob([wav.toBuffer()], { type: 'audio/wav' });\n\n  const formData = new FormData();\n  formData.append('file', new File([wavBlob], 'voice.wav', { type: 'audio/wav' }));\n\n  const res = await api.post('/api/v1/transcribe', formData);\n  return res.data.transcription;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}