{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview binary parser.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { endianness } from './lib/endianness';\nimport { pack as packUTF8, unpack as unpackUTF8 } from './lib/utf8-parser';\nimport { IntParser } from './lib/int-parser';\nimport { FloatParser } from './lib/float-parser';\n\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.\r\n * @param {number} [index=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The index to stop reading, non inclusive.\r\n * @return {string}\r\n */\nexport function unpackString(buffer, index = 0, end = buffer.length) {\n  return unpackUTF8(buffer, index, end);\n}\n\n/**\r\n * Write a string of UTF-8 characters as a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @return {!Array<number>} The UTF-8 string bytes.\r\n */\nexport function packString(str) {\n  /** @type {!Array<number>} */\n  let buffer = [];\n  packUTF8(str, buffer);\n  return buffer;\n}\n\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @param {!(Uint8Array|Array<number>)} buffer The output buffer.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\nexport function packStringTo(str, buffer, index = 0) {\n  return packUTF8(str, buffer, index);\n}\n\n// Numbers\n/**\r\n * Pack a array of numbers to a byte buffer.\r\n * All other packing functions are interfaces to this function.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The buffer to write on.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\nexport function packArrayTo(values, theType, buffer, index = 0) {\n  theType = theType || {};\n  /** @type {!Object} */\n  let packer = getParser_(theType.bits, theType.fp, theType.signed);\n  /** @type {number} */\n  let offset = Math.ceil(theType.bits / 8);\n  /** @type {number} */\n  let i = 0;\n  /** @type {number} */\n  let start = index;\n  for (let valuesLen = values.length; i < valuesLen; i++) {\n    index = packer.pack(buffer, values[i], index);\n  }\n  if (theType.be) {\n    endianness(buffer, offset, start, index);\n  }\n  return index;\n}\n\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @throws {Error} If the type definition is not valid.\r\n */\nexport function unpackArrayTo(buffer, theType, output, start = 0, end = buffer.length) {\n  theType = theType || {};\n  /** @type {!Object} */\n  let parser = getParser_(theType.bits, theType.fp, theType.signed);\n  // getUnpackLen_ will adjust the end index according to the size\n  // of the input buffer and the byte offset or throw a error on bad\n  // end index if safe=true\n  end = getUnpackLen_(buffer, start, end, parser.offset);\n  if (theType.be) {\n    /** @type {!(Uint8Array|Array<number>)} */\n    let readBuffer = copyBuffer_(buffer);\n    if (theType.be) {\n      endianness(readBuffer, parser.offset, start, end);\n    }\n    unpack_(readBuffer, output, start, end, parser);\n  } else {\n    unpack_(buffer, output, start, end, parser);\n  }\n}\n\n/**\r\n * Pack a number to a byte buffer.\r\n * @param {number} value The value.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer to write on.\r\n * @param {number} [index=0] The buffer index to write.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\nexport function packTo(value, theType, buffer, index = 0) {\n  return packArrayTo([value], theType, buffer, index);\n}\n\n/**\r\n * Pack a number as a array of bytes.\r\n * @param {number} value The number to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @return {!Array<number>} The packed value.\r\n * @throws {Error} If the type definition is not valid.\r\n */\nexport function pack(value, theType) {\n  /** @type {!Array<number>} */\n  let output = [];\n  packTo(value, theType, output, 0);\n  return output;\n}\n\n/**\r\n * Unpack a number from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [index=0] The buffer index to read.\r\n * @return {number}\r\n * @throws {Error} If the type definition is not valid.\r\n */\nexport function unpack(buffer, theType, index = 0) {\n  let output = [];\n  unpackArrayTo(buffer, theType, output, index, index + Math.ceil(theType.bits / 8));\n  return output[0];\n}\n\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {!Object} parser The parser.\r\n * @private\r\n */\nfunction unpack_(buffer, output, start, end, parser) {\n  /** @type {number} */\n  let offset = parser.offset;\n  for (let index = 0, j = start; j < end; j += offset, index++) {\n    output[index] = parser.unpack(buffer, j);\n  }\n}\n\n/**\r\n * Copy a byte buffer as a Array or Uint8Array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @return {!(Uint8Array|Array<number>)}\r\n * @private\r\n */\nfunction copyBuffer_(buffer) {\n  return new Uint8Array(buffer);\n}\n\n/**\r\n * Adjust the end index according to the input buffer length and the\r\n * type offset.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {number} offset The number of bytes used by the type.\r\n * @private\r\n */\nfunction getUnpackLen_(buffer, start, end, offset) {\n  /** @type {number} */\n  let extra = (end - start) % offset;\n  return end - extra;\n}\n\n/**\r\n * Return a parser for int, uint or fp numbers.\r\n * @param {number} bits The number of bits.\r\n * @param {boolean|undefined} fp True for fp numbers, false otherwise.\r\n * @param {boolean|undefined} signed True for signed ints, false otherwise.\r\n * @return {!Object}\r\n * @private\r\n */\nfunction getParser_(bits, fp, signed) {\n  if (fp && bits == 32) {\n    return new FloatParser(8, 23);\n  } else if (fp && bits == 64) {\n    return new FloatParser(11, 52);\n  }\n  return new IntParser(bits, signed);\n}","map":{"version":3,"names":["endianness","pack","packUTF8","unpack","unpackUTF8","IntParser","FloatParser","unpackString","buffer","index","end","length","packString","str","packStringTo","packArrayTo","values","theType","packer","getParser_","bits","fp","signed","offset","Math","ceil","i","start","valuesLen","be","unpackArrayTo","output","parser","getUnpackLen_","readBuffer","copyBuffer_","unpack_","packTo","value","j","Uint8Array","extra"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/parsers/binary/index.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview binary parser.\r\n * @see https://github.com/rochars/byte-data\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { endianness } from './lib/endianness';\r\nimport { pack as packUTF8, unpack as unpackUTF8 } from './lib/utf8-parser';\r\nimport { IntParser } from './lib/int-parser';\r\nimport { FloatParser } from './lib/float-parser';\r\n\r\n/**\r\n * Read a string of UTF-8 characters from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer A byte buffer.\r\n * @param {number} [index=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The index to stop reading, non inclusive.\r\n * @return {string}\r\n */\r\nexport function unpackString(buffer, index=0, end=buffer.length) {\r\n  return unpackUTF8(buffer, index, end);\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters as a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @return {!Array<number>} The UTF-8 string bytes.\r\n */\r\nexport function packString(str) {\r\n  /** @type {!Array<number>} */\r\n  let buffer = [];\r\n  packUTF8(str, buffer);\r\n  return buffer;\r\n}\r\n\r\n/**\r\n * Write a string of UTF-8 characters to a byte buffer.\r\n * @param {string} str The string to pack.\r\n * @param {!(Uint8Array|Array<number>)} buffer The output buffer.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write in the buffer.\r\n */\r\nexport function packStringTo(str, buffer, index=0) {\r\n  return packUTF8(str, buffer, index);\r\n}\r\n\r\n// Numbers\r\n/**\r\n * Pack a array of numbers to a byte buffer.\r\n * All other packing functions are interfaces to this function.\r\n * @param {!(Array<number>|TypedArray)} values The values to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The buffer to write on.\r\n * @param {number} [index=0] The buffer index to start writing.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function packArrayTo(values, theType, buffer, index=0) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let packer = getParser_(theType.bits, theType.fp, theType.signed);\r\n  /** @type {number} */\r\n  let offset = Math.ceil(theType.bits / 8);\r\n  /** @type {number} */\r\n  let i = 0;\r\n  /** @type {number} */\r\n  let start = index;\r\n  for (let valuesLen = values.length; i < valuesLen; i++) {\r\n    index = packer.pack(buffer, values[i], index);\r\n  }\r\n  if (theType.be) {\r\n    endianness(buffer, offset, start, index);\r\n  }\r\n  return index;\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * All other unpacking functions are interfaces to this function.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} [start=0] The buffer index to start reading.\r\n * @param {number} [end=buffer.length] The buffer index to stop reading.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpackArrayTo(\r\n    buffer, theType, output, start=0, end=buffer.length) {\r\n  theType = theType || {};\r\n  /** @type {!Object} */\r\n  let parser = getParser_(theType.bits, theType.fp, theType.signed);\r\n  // getUnpackLen_ will adjust the end index according to the size\r\n  // of the input buffer and the byte offset or throw a error on bad\r\n  // end index if safe=true\r\n  end = getUnpackLen_(buffer, start, end, parser.offset);\r\n  if (theType.be) {\r\n    /** @type {!(Uint8Array|Array<number>)} */\r\n    let readBuffer = copyBuffer_(buffer);\r\n    if (theType.be) {\r\n      endianness(readBuffer, parser.offset, start, end);\r\n    }\r\n    unpack_(readBuffer, output, start, end, parser);\r\n  } else {\r\n    unpack_(buffer, output, start, end, parser);\r\n  }\r\n}\r\n\r\n/**\r\n * Pack a number to a byte buffer.\r\n * @param {number} value The value.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer to write on.\r\n * @param {number} [index=0] The buffer index to write.\r\n * @return {number} The next index to write.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function packTo(value, theType, buffer, index=0) {\r\n  return packArrayTo([value], theType, buffer, index);\r\n}\r\n\r\n/**\r\n * Pack a number as a array of bytes.\r\n * @param {number} value The number to pack.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @return {!Array<number>} The packed value.\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function pack(value, theType) {\r\n  /** @type {!Array<number>} */\r\n  let output = [];\r\n  packTo(value, theType, output, 0);\r\n  return output;\r\n}\r\n\r\n/**\r\n * Unpack a number from a byte buffer.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!{bits:number,\r\n *   fp: (boolean|undefined),\r\n *   signed: (boolean|undefined),\r\n *   be: (boolean|undefined)}} theType The type definition.\r\n * @param {number} [index=0] The buffer index to read.\r\n * @return {number}\r\n * @throws {Error} If the type definition is not valid.\r\n */\r\nexport function unpack(buffer, theType, index=0) {\r\n  let output = [];\r\n  unpackArrayTo(buffer, theType, output,\r\n    index, index + Math.ceil(theType.bits / 8));\r\n  return output[0];\r\n}\r\n\r\n/**\r\n * Unpack a array of numbers from a byte buffer to a array or a typed array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {!(TypedArray|Array<number>)} output The output array or typed array.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {!Object} parser The parser.\r\n * @private\r\n */\r\nfunction unpack_(buffer, output, start, end, parser) {\r\n  /** @type {number} */\r\n  let offset = parser.offset;\r\n  for (let index = 0, j = start; j < end; j += offset, index++) {\r\n    output[index] = parser.unpack(buffer, j);\r\n  }\r\n}\r\n\r\n/**\r\n * Copy a byte buffer as a Array or Uint8Array.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @return {!(Uint8Array|Array<number>)}\r\n * @private\r\n */\r\nfunction copyBuffer_(buffer) {\r\n  return new Uint8Array(buffer);\r\n}\r\n\r\n/**\r\n * Adjust the end index according to the input buffer length and the\r\n * type offset.\r\n * @param {!(Uint8Array|Array<number>)} buffer The byte buffer.\r\n * @param {number} start The buffer index to start reading.\r\n * @param {number} end The buffer index to stop reading.\r\n * @param {number} offset The number of bytes used by the type.\r\n * @private\r\n */\r\nfunction getUnpackLen_(buffer, start, end, offset) {\r\n  /** @type {number} */\r\n  let extra = (end - start) % offset;\r\n  return end - extra;\r\n}\r\n\r\n/**\r\n * Return a parser for int, uint or fp numbers.\r\n * @param {number} bits The number of bits.\r\n * @param {boolean|undefined} fp True for fp numbers, false otherwise.\r\n * @param {boolean|undefined} signed True for signed ints, false otherwise.\r\n * @return {!Object}\r\n * @private\r\n */\r\nfunction getParser_(bits, fp, signed) {\r\n  if (fp && bits == 32) {\r\n    return new FloatParser(8, 23);\r\n  } else if(fp && bits == 64) {\r\n    return new FloatParser(11, 52);\r\n  }\r\n  return new IntParser(bits, signed);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}