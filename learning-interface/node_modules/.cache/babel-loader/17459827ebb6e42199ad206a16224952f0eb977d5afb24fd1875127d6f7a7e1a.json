{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { RIFFFile } from './riff-file';\nimport { unpackString, unpack } from './parsers/binary';\n\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\nexport class WaveFileReader extends RIFFFile {\n  constructor() {\n    super();\n    // Include 'RF64' as a supported container format\n    this.supported_containers.push('RF64');\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.fmt = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {number} */\n      audioFormat: 0,\n      /** @type {number} */\n      numChannels: 0,\n      /** @type {number} */\n      sampleRate: 0,\n      /** @type {number} */\n      byteRate: 0,\n      /** @type {number} */\n      blockAlign: 0,\n      /** @type {number} */\n      bitsPerSample: 0,\n      /** @type {number} */\n      cbSize: 0,\n      /** @type {number} */\n      validBitsPerSample: 0,\n      /** @type {number} */\n      dwChannelMask: 0,\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\n      subformat: []\n    };\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.fact = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {number} */\n      dwSampleLength: 0\n    };\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.cue = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {number} */\n      dwCuePoints: 0,\n      /** @type {!Array<!Object>} */\n      points: []\n    };\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.smpl = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {number} */\n      dwManufacturer: 0,\n      /** @type {number} */\n      dwProduct: 0,\n      /** @type {number} */\n      dwSamplePeriod: 0,\n      /** @type {number} */\n      dwMIDIUnityNote: 0,\n      /** @type {number} */\n      dwMIDIPitchFraction: 0,\n      /** @type {number} */\n      dwSMPTEFormat: 0,\n      /** @type {number} */\n      dwSMPTEOffset: 0,\n      /** @type {number} */\n      dwNumSampleLoops: 0,\n      /** @type {number} */\n      dwSamplerData: 0,\n      /** @type {!Array<!Object>} */\n      loops: []\n    };\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.bext = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {string} */\n      description: '',\n      //256\n      /** @type {string} */\n      originator: '',\n      //32\n      /** @type {string} */\n      originatorReference: '',\n      //32\n      /** @type {string} */\n      originationDate: '',\n      //10\n      /** @type {string} */\n      originationTime: '',\n      //8\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\n      timeReference: [0, 0],\n      /** @type {number} */\n      version: 0,\n      //WORD\n      /** @type {string} */\n      UMID: '',\n      // 64 chars\n      /** @type {number} */\n      loudnessValue: 0,\n      //WORD\n      /** @type {number} */\n      loudnessRange: 0,\n      //WORD\n      /** @type {number} */\n      maxTruePeakLevel: 0,\n      //WORD\n      /** @type {number} */\n      maxMomentaryLoudness: 0,\n      //WORD\n      /** @type {number} */\n      maxShortTermLoudness: 0,\n      //WORD\n      /** @type {string} */\n      reserved: '',\n      //180\n      /** @type {string} */\n      codingHistory: '' // string, unlimited\n    };\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.iXML = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {string} */\n      value: ''\n    };\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.ds64 = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {number} */\n      riffSizeHigh: 0,\n      // DWORD\n      /** @type {number} */\n      riffSizeLow: 0,\n      // DWORD\n      /** @type {number} */\n      dataSizeHigh: 0,\n      // DWORD\n      /** @type {number} */\n      dataSizeLow: 0,\n      // DWORD\n      /** @type {number} */\n      originationTime: 0,\n      // DWORD\n      /** @type {number} */\n      sampleCountHigh: 0,\n      // DWORD\n      /** @type {number} */\n      sampleCountLow: 0 // DWORD\n      /** @type {number} */\n      //'tableLength': 0, // DWORD\n      /** @type {!Array<number>} */\n      //'table': []\n    };\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.data = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {!Uint8Array} */\n      samples: new Uint8Array(0)\n    };\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\n    this.LIST = [];\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this.junk = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {!Array<number>} */\n      chunkData: []\n    };\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\n    this._PMX = {\n      /** @type {string} */\n      chunkId: '',\n      /** @type {number} */\n      chunkSize: 0,\n      /** @type {string} */\n      value: ''\n    };\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\n    this.uInt16 = {\n      bits: 16,\n      be: false,\n      signed: false,\n      fp: false\n    };\n  }\n\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\n  fromBuffer(wavBuffer, samples = true) {\n    // Always should reset the chunks when reading from a buffer\n    this.clearHeaders();\n    this.setSignature(wavBuffer);\n    this.uInt16.be = this.uInt32.be;\n    if (this.format != 'WAVE') {\n      throw Error('Could not find the \"WAVE\" format identifier');\n    }\n    this.readDs64Chunk_(wavBuffer);\n    this.readFmtChunk_(wavBuffer);\n    this.readFactChunk_(wavBuffer);\n    this.readBextChunk_(wavBuffer);\n    this.readiXMLChunk_(wavBuffer);\n    this.readCueChunk_(wavBuffer);\n    this.readSmplChunk_(wavBuffer);\n    this.readDataChunk_(wavBuffer, samples);\n    this.readJunkChunk_(wavBuffer);\n    this.readLISTChunk_(wavBuffer);\n    this.read_PMXChunk_(wavBuffer);\n  }\n\n  /**\r\n   * Reset the chunks of the WaveFileReader instance.\r\n   * @protected\r\n   * @ignore\r\n   */\n  clearHeaders() {\n    /** @type {!Object} */\n    let tmpWav = new WaveFileReader();\n    Object.assign(this.fmt, tmpWav.fmt);\n    Object.assign(this.fact, tmpWav.fact);\n    Object.assign(this.cue, tmpWav.cue);\n    Object.assign(this.smpl, tmpWav.smpl);\n    Object.assign(this.bext, tmpWav.bext);\n    Object.assign(this.iXML, tmpWav.iXML);\n    Object.assign(this.ds64, tmpWav.ds64);\n    Object.assign(this.data, tmpWav.data);\n    this.LIST = [];\n    Object.assign(this.junk, tmpWav.junk);\n    Object.assign(this._PMX, tmpWav._PMX);\n  }\n\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\n  readFmtChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('fmt ');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.fmt.chunkId = chunk.chunkId;\n      this.fmt.chunkSize = chunk.chunkSize;\n      this.fmt.audioFormat = this.readUInt16_(buffer);\n      this.fmt.numChannels = this.readUInt16_(buffer);\n      this.fmt.sampleRate = this.readUInt32(buffer);\n      this.fmt.byteRate = this.readUInt32(buffer);\n      this.fmt.blockAlign = this.readUInt16_(buffer);\n      this.fmt.bitsPerSample = this.readUInt16_(buffer);\n      this.readFmtExtension_(buffer);\n    } else {\n      throw Error('Could not find the \"fmt \" chunk');\n    }\n  }\n\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readFmtExtension_(buffer) {\n    if (this.fmt.chunkSize > 16) {\n      this.fmt.cbSize = this.readUInt16_(buffer);\n      if (this.fmt.chunkSize > 18) {\n        this.fmt.validBitsPerSample = this.readUInt16_(buffer);\n        if (this.fmt.chunkSize > 20) {\n          this.fmt.dwChannelMask = this.readUInt32(buffer);\n          this.fmt.subformat = [this.readUInt32(buffer), this.readUInt32(buffer), this.readUInt32(buffer), this.readUInt32(buffer)];\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readFactChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('fact');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.fact.chunkId = chunk.chunkId;\n      this.fact.chunkSize = chunk.chunkSize;\n      this.fact.dwSampleLength = this.readUInt32(buffer);\n    }\n  }\n\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readCueChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('cue ');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.cue.chunkId = chunk.chunkId;\n      this.cue.chunkSize = chunk.chunkSize;\n      this.cue.dwCuePoints = this.readUInt32(buffer);\n      for (let i = 0; i < this.cue.dwCuePoints; i++) {\n        this.cue.points.push({\n          dwName: this.readUInt32(buffer),\n          dwPosition: this.readUInt32(buffer),\n          fccChunk: this.readString(buffer, 4),\n          dwChunkStart: this.readUInt32(buffer),\n          dwBlockStart: this.readUInt32(buffer),\n          dwSampleOffset: this.readUInt32(buffer)\n        });\n      }\n    }\n  }\n\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readSmplChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('smpl');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.smpl.chunkId = chunk.chunkId;\n      this.smpl.chunkSize = chunk.chunkSize;\n      this.smpl.dwManufacturer = this.readUInt32(buffer);\n      this.smpl.dwProduct = this.readUInt32(buffer);\n      this.smpl.dwSamplePeriod = this.readUInt32(buffer);\n      this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\n      this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\n      this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\n      this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\n      this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\n      this.smpl.dwSamplerData = this.readUInt32(buffer);\n      for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\n        this.smpl.loops.push({\n          dwName: this.readUInt32(buffer),\n          dwType: this.readUInt32(buffer),\n          dwStart: this.readUInt32(buffer),\n          dwEnd: this.readUInt32(buffer),\n          dwFraction: this.readUInt32(buffer),\n          dwPlayCount: this.readUInt32(buffer)\n        });\n      }\n    }\n  }\n\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {boolean} samples True if the samples should be loaded.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\n  readDataChunk_(buffer, samples) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('data');\n    if (chunk) {\n      this.data.chunkId = 'data';\n      this.data.chunkSize = chunk.chunkSize;\n      if (samples) {\n        this.data.samples = buffer.slice(chunk.chunkData.start, chunk.chunkData.end);\n      }\n    } else {\n      throw Error('Could not find the \"data\" chunk');\n    }\n  }\n\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readBextChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('bext');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.bext.chunkId = chunk.chunkId;\n      this.bext.chunkSize = chunk.chunkSize;\n      this.bext.description = this.readString(buffer, 256);\n      this.bext.originator = this.readString(buffer, 32);\n      this.bext.originatorReference = this.readString(buffer, 32);\n      this.bext.originationDate = this.readString(buffer, 10);\n      this.bext.originationTime = this.readString(buffer, 8);\n      this.bext.timeReference = [this.readUInt32(buffer), this.readUInt32(buffer)];\n      this.bext.version = this.readUInt16_(buffer);\n      this.bext.UMID = this.readString(buffer, 64);\n      this.bext.loudnessValue = this.readUInt16_(buffer);\n      this.bext.loudnessRange = this.readUInt16_(buffer);\n      this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\n      this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\n      this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\n      this.bext.reserved = this.readString(buffer, 180);\n      this.bext.codingHistory = this.readString(buffer, this.bext.chunkSize - 602);\n    }\n  }\n\n  /**\r\n   * Read the 'iXML' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readiXMLChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('iXML');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.iXML.chunkId = chunk.chunkId;\n      this.iXML.chunkSize = chunk.chunkSize;\n      this.iXML.value = unpackString(buffer, this.head, this.head + this.iXML.chunkSize);\n    }\n  }\n\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\n  readDs64Chunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('ds64');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this.ds64.chunkId = chunk.chunkId;\n      this.ds64.chunkSize = chunk.chunkSize;\n      this.ds64.riffSizeHigh = this.readUInt32(buffer);\n      this.ds64.riffSizeLow = this.readUInt32(buffer);\n      this.ds64.dataSizeHigh = this.readUInt32(buffer);\n      this.ds64.dataSizeLow = this.readUInt32(buffer);\n      this.ds64.originationTime = this.readUInt32(buffer);\n      this.ds64.sampleCountHigh = this.readUInt32(buffer);\n      this.ds64.sampleCountLow = this.readUInt32(buffer);\n      //if (wav.ds64.chunkSize > 28) {\n      //  wav.ds64.tableLength = unpack(\n      //    chunkData.slice(28, 32), uInt32_);\n      //  wav.ds64.table = chunkData.slice(\n      //     32, 32 + wav.ds64.tableLength);\n      //}\n    } else {\n      if (this.container == 'RF64') {\n        throw Error('Could not find the \"ds64\" chunk');\n      }\n    }\n  }\n\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readLISTChunk_(buffer) {\n    /** @type {?Object} */\n    let listChunks = this.findChunk('LIST', true);\n    if (listChunks !== null) {\n      for (let j = 0; j < listChunks.length; j++) {\n        /** @type {!Object} */\n        let subChunk = listChunks[j];\n        this.LIST.push({\n          chunkId: subChunk.chunkId,\n          chunkSize: subChunk.chunkSize,\n          format: subChunk.format,\n          subChunks: []\n        });\n        for (let x = 0; x < subChunk.subChunks.length; x++) {\n          this.readLISTSubChunks_(subChunk.subChunks[x], subChunk.format, buffer);\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readLISTSubChunks_(subChunk, format, buffer) {\n    if (format == 'adtl') {\n      if (['labl', 'note', 'ltxt'].indexOf(subChunk.chunkId) > -1) {\n        this.readLISTadtlSubChunks_(buffer, subChunk);\n      }\n      // RIFF INFO tags like ICRD, ISFT, ICMT\n    } else if (format == 'INFO') {\n      this.readLISTINFOSubChunks_(buffer, subChunk);\n    }\n  }\n\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\n  readLISTadtlSubChunks_(buffer, subChunk) {\n    this.head = subChunk.chunkData.start;\n    /** @type {!Object<string, string|number>} */\n    let item = {\n      chunkId: subChunk.chunkId,\n      chunkSize: subChunk.chunkSize,\n      dwName: this.readUInt32(buffer)\n    };\n    if (subChunk.chunkId == 'ltxt') {\n      item.dwSampleLength = this.readUInt32(buffer);\n      item.dwPurposeID = this.readUInt32(buffer);\n      item.dwCountry = this.readUInt16_(buffer);\n      item.dwLanguage = this.readUInt16_(buffer);\n      item.dwDialect = this.readUInt16_(buffer);\n      item.dwCodePage = this.readUInt16_(buffer);\n      item.value = ''; // kept for compatibility\n    } else {\n      item.value = this.readZSTR_(buffer, this.head);\n    }\n    this.LIST[this.LIST.length - 1].subChunks.push(item);\n  }\n\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\n  readLISTINFOSubChunks_(buffer, subChunk) {\n    this.head = subChunk.chunkData.start;\n    this.LIST[this.LIST.length - 1].subChunks.push({\n      chunkId: subChunk.chunkId,\n      chunkSize: subChunk.chunkSize,\n      value: this.readZSTR_(buffer, this.head)\n    });\n  }\n\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  readJunkChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('junk');\n    if (chunk) {\n      this.junk = {\n        chunkId: chunk.chunkId,\n        chunkSize: chunk.chunkSize,\n        chunkData: [].slice.call(buffer.slice(chunk.chunkData.start, chunk.chunkData.end))\n      };\n    }\n  }\n\n  /**\r\n   * Read the '_PMX' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\n  read_PMXChunk_(buffer) {\n    /** @type {?Object} */\n    let chunk = this.findChunk('_PMX');\n    if (chunk) {\n      this.head = chunk.chunkData.start;\n      this._PMX.chunkId = chunk.chunkId;\n      this._PMX.chunkSize = chunk.chunkSize;\n      this._PMX.value = unpackString(buffer, this.head, this.head + this._PMX.chunkSize);\n    }\n  }\n\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number=} [index=0] the index to start reading.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\n  readZSTR_(bytes, index = 0) {\n    for (let i = index; i < bytes.length; i++) {\n      this.head++;\n      if (bytes[i] === 0) {\n        break;\n      }\n    }\n    return unpackString(bytes, index, this.head - 1);\n  }\n\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @private\r\n   */\n  readUInt16_(bytes) {\n    /** @type {number} */\n    let value = unpack(bytes, this.uInt16, this.head);\n    this.head += 2;\n    return value;\n  }\n}","map":{"version":3,"names":["RIFFFile","unpackString","unpack","WaveFileReader","constructor","supported_containers","push","fmt","chunkId","chunkSize","audioFormat","numChannels","sampleRate","byteRate","blockAlign","bitsPerSample","cbSize","validBitsPerSample","dwChannelMask","subformat","fact","dwSampleLength","cue","dwCuePoints","points","smpl","dwManufacturer","dwProduct","dwSamplePeriod","dwMIDIUnityNote","dwMIDIPitchFraction","dwSMPTEFormat","dwSMPTEOffset","dwNumSampleLoops","dwSamplerData","loops","bext","description","originator","originatorReference","originationDate","originationTime","timeReference","version","UMID","loudnessValue","loudnessRange","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","reserved","codingHistory","iXML","value","ds64","riffSizeHigh","riffSizeLow","dataSizeHigh","dataSizeLow","sampleCountHigh","sampleCountLow","data","samples","Uint8Array","LIST","junk","chunkData","_PMX","uInt16","bits","be","signed","fp","fromBuffer","wavBuffer","clearHeaders","setSignature","uInt32","format","Error","readDs64Chunk_","readFmtChunk_","readFactChunk_","readBextChunk_","readiXMLChunk_","readCueChunk_","readSmplChunk_","readDataChunk_","readJunkChunk_","readLISTChunk_","read_PMXChunk_","tmpWav","Object","assign","buffer","chunk","findChunk","head","start","readUInt16_","readUInt32","readFmtExtension_","i","dwName","dwPosition","fccChunk","readString","dwChunkStart","dwBlockStart","dwSampleOffset","dwType","dwStart","dwEnd","dwFraction","dwPlayCount","slice","end","container","listChunks","j","length","subChunk","subChunks","x","readLISTSubChunks_","indexOf","readLISTadtlSubChunks_","readLISTINFOSubChunks_","item","dwPurposeID","dwCountry","dwLanguage","dwDialect","dwCodePage","readZSTR_","call","bytes","index"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/wavefile-reader.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The WaveFileReader class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { RIFFFile } from './riff-file';\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to read wav files.\r\n * @extends RIFFFile\r\n */\r\nexport class WaveFileReader extends RIFFFile {\r\n\r\n  constructor() {\r\n    super();\r\n    // Include 'RF64' as a supported container format\r\n    this.supported_containers.push('RF64');\r\n    /**\r\n     * The data of the 'fmt' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fmt = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      audioFormat: 0,\r\n      /** @type {number} */\r\n      numChannels: 0,\r\n      /** @type {number} */\r\n      sampleRate: 0,\r\n      /** @type {number} */\r\n      byteRate: 0,\r\n      /** @type {number} */\r\n      blockAlign: 0,\r\n      /** @type {number} */\r\n      bitsPerSample: 0,\r\n      /** @type {number} */\r\n      cbSize: 0,\r\n      /** @type {number} */\r\n      validBitsPerSample: 0,\r\n      /** @type {number} */\r\n      dwChannelMask: 0,\r\n      /**\r\n       * 4 32-bit values representing a 128-bit ID\r\n       * @type {!Array<number>}\r\n       */\r\n      subformat: []\r\n    };\r\n    /**\r\n     * The data of the 'fact' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.fact = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwSampleLength: 0\r\n    };\r\n    /**\r\n     * The data of the 'cue ' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.cue = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwCuePoints: 0,\r\n      /** @type {!Array<!Object>} */\r\n      points: [],\r\n    };\r\n    /**\r\n     * The data of the 'smpl' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.smpl = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      dwManufacturer: 0,\r\n      /** @type {number} */\r\n      dwProduct: 0,\r\n      /** @type {number} */\r\n      dwSamplePeriod: 0,\r\n      /** @type {number} */\r\n      dwMIDIUnityNote: 0,\r\n      /** @type {number} */\r\n      dwMIDIPitchFraction: 0,\r\n      /** @type {number} */\r\n      dwSMPTEFormat: 0,\r\n      /** @type {number} */\r\n      dwSMPTEOffset: 0,\r\n      /** @type {number} */\r\n      dwNumSampleLoops: 0,\r\n      /** @type {number} */\r\n      dwSamplerData: 0,\r\n      /** @type {!Array<!Object>} */\r\n      loops: []\r\n    };\r\n    /**\r\n     * The data of the 'bext' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.bext = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      description: '', //256\r\n      /** @type {string} */\r\n      originator: '', //32\r\n      /** @type {string} */\r\n      originatorReference: '', //32\r\n      /** @type {string} */\r\n      originationDate: '', //10\r\n      /** @type {string} */\r\n      originationTime: '', //8\r\n      /**\r\n       * 2 32-bit values, timeReference high and low\r\n       * @type {!Array<number>}\r\n       */\r\n      timeReference: [0, 0],\r\n      /** @type {number} */\r\n      version: 0, //WORD\r\n      /** @type {string} */\r\n      UMID: '', // 64 chars\r\n      /** @type {number} */\r\n      loudnessValue: 0, //WORD\r\n      /** @type {number} */\r\n      loudnessRange: 0, //WORD\r\n      /** @type {number} */\r\n      maxTruePeakLevel: 0, //WORD\r\n      /** @type {number} */\r\n      maxMomentaryLoudness: 0, //WORD\r\n      /** @type {number} */\r\n      maxShortTermLoudness: 0, //WORD\r\n      /** @type {string} */\r\n      reserved: '', //180\r\n      /** @type {string} */\r\n      codingHistory: '' // string, unlimited\r\n    };\r\n    /**\r\n     * The data of the 'iXML' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.iXML = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * The data of the 'ds64' chunk.\r\n     * Used only with RF64 files.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.ds64 = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {number} */\r\n      riffSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      riffSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      dataSizeLow: 0, // DWORD\r\n      /** @type {number} */\r\n      originationTime: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountHigh: 0, // DWORD\r\n      /** @type {number} */\r\n      sampleCountLow: 0 // DWORD\r\n      /** @type {number} */\r\n      //'tableLength': 0, // DWORD\r\n      /** @type {!Array<number>} */\r\n      //'table': []\r\n    };\r\n    /**\r\n     * The data of the 'data' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.data = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Uint8Array} */\r\n      samples: new Uint8Array(0)\r\n    };\r\n    /**\r\n     * The data of the 'LIST' chunks.\r\n     * Each item in this list look like this:\r\n     *  {\r\n     *      chunkId: '',\r\n     *      chunkSize: 0,\r\n     *      format: '',\r\n     *      subChunks: []\r\n     *   }\r\n     * @type {!Array<!Object>}\r\n     */\r\n    this.LIST = [];\r\n    /**\r\n     * The data of the 'junk' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this.junk = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {!Array<number>} */\r\n      chunkData: []\r\n    };\r\n    /**\r\n     * The data of the '_PMX' chunk.\r\n     * @type {!Object<string, *>}\r\n     */\r\n    this._PMX = {\r\n      /** @type {string} */\r\n      chunkId: '',\r\n      /** @type {number} */\r\n      chunkSize: 0,\r\n      /** @type {string} */\r\n      value: ''\r\n    };\r\n    /**\r\n     * @type {{be: boolean, bits: number, fp: boolean, signed: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt16 = {bits: 16, be: false, signed: false, fp: false};\r\n  }\r\n\r\n  /**\r\n   * Set up the WaveFileReader object from a byte buffer.\r\n   * @param {!Uint8Array} wavBuffer The buffer.\r\n   * @param {boolean=} [samples=true] True if the samples should be loaded.\r\n   * @throws {Error} If container is not RIFF, RIFX or RF64.\r\n   * @throws {Error} If format is not WAVE.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   */\r\n  fromBuffer(wavBuffer, samples=true) {\r\n    // Always should reset the chunks when reading from a buffer\r\n    this.clearHeaders();\r\n    this.setSignature(wavBuffer);\r\n    this.uInt16.be = this.uInt32.be;\r\n    if (this.format != 'WAVE') {\r\n      throw Error('Could not find the \"WAVE\" format identifier');\r\n    }\r\n    this.readDs64Chunk_(wavBuffer);\r\n    this.readFmtChunk_(wavBuffer);\r\n    this.readFactChunk_(wavBuffer);\r\n    this.readBextChunk_(wavBuffer);\r\n    this.readiXMLChunk_(wavBuffer);\r\n    this.readCueChunk_(wavBuffer);\r\n    this.readSmplChunk_(wavBuffer);\r\n    this.readDataChunk_(wavBuffer, samples);\r\n    this.readJunkChunk_(wavBuffer);\r\n    this.readLISTChunk_(wavBuffer);\r\n    this.read_PMXChunk_(wavBuffer);\r\n  }\r\n\r\n  /**\r\n   * Reset the chunks of the WaveFileReader instance.\r\n   * @protected\r\n   * @ignore\r\n   */\r\n  clearHeaders() {\r\n    /** @type {!Object} */\r\n    let tmpWav = new WaveFileReader();\r\n    Object.assign(this.fmt, tmpWav.fmt);\r\n    Object.assign(this.fact, tmpWav.fact);\r\n    Object.assign(this.cue, tmpWav.cue);\r\n    Object.assign(this.smpl, tmpWav.smpl);\r\n    Object.assign(this.bext, tmpWav.bext);\r\n    Object.assign(this.iXML, tmpWav.iXML);\r\n    Object.assign(this.ds64, tmpWav.ds64);\r\n    Object.assign(this.data, tmpWav.data);\r\n    this.LIST = [];\r\n    Object.assign(this.junk, tmpWav.junk);\r\n    Object.assign(this._PMX, tmpWav._PMX);\r\n  }\r\n  \r\n  /**\r\n   * Read the 'fmt ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'fmt ' chunk is found.\r\n   * @private\r\n   */\r\n  readFmtChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fmt ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fmt.chunkId = chunk.chunkId;\r\n      this.fmt.chunkSize = chunk.chunkSize;\r\n      this.fmt.audioFormat = this.readUInt16_(buffer);\r\n      this.fmt.numChannels = this.readUInt16_(buffer);\r\n      this.fmt.sampleRate = this.readUInt32(buffer);\r\n      this.fmt.byteRate = this.readUInt32(buffer);\r\n      this.fmt.blockAlign = this.readUInt16_(buffer);\r\n      this.fmt.bitsPerSample = this.readUInt16_(buffer);\r\n      this.readFmtExtension_(buffer);\r\n    } else {\r\n      throw Error('Could not find the \"fmt \" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fmt ' chunk extension.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFmtExtension_(buffer) {\r\n    if (this.fmt.chunkSize > 16) {\r\n      this.fmt.cbSize = this.readUInt16_(buffer);\r\n      if (this.fmt.chunkSize > 18) {\r\n        this.fmt.validBitsPerSample = this.readUInt16_(buffer);\r\n        if (this.fmt.chunkSize > 20) {\r\n          this.fmt.dwChannelMask = this.readUInt32(buffer);\r\n          this.fmt.subformat = [\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer),\r\n            this.readUInt32(buffer)];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'fact' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readFactChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('fact');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.fact.chunkId = chunk.chunkId;\r\n      this.fact.chunkSize = chunk.chunkSize;\r\n      this.fact.dwSampleLength = this.readUInt32(buffer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'cue ' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readCueChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('cue ');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.cue.chunkId = chunk.chunkId;\r\n      this.cue.chunkSize = chunk.chunkSize;\r\n      this.cue.dwCuePoints = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.cue.dwCuePoints; i++) {\r\n        this.cue.points.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwPosition: this.readUInt32(buffer),\r\n          fccChunk: this.readString(buffer, 4),\r\n          dwChunkStart: this.readUInt32(buffer),\r\n          dwBlockStart: this.readUInt32(buffer),\r\n          dwSampleOffset: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'smpl' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readSmplChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('smpl');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.smpl.chunkId = chunk.chunkId;\r\n      this.smpl.chunkSize = chunk.chunkSize;\r\n      this.smpl.dwManufacturer = this.readUInt32(buffer);\r\n      this.smpl.dwProduct = this.readUInt32(buffer);\r\n      this.smpl.dwSamplePeriod = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIUnityNote = this.readUInt32(buffer);\r\n      this.smpl.dwMIDIPitchFraction = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEFormat = this.readUInt32(buffer);\r\n      this.smpl.dwSMPTEOffset = this.readUInt32(buffer);\r\n      this.smpl.dwNumSampleLoops = this.readUInt32(buffer);\r\n      this.smpl.dwSamplerData = this.readUInt32(buffer);\r\n      for (let i = 0; i < this.smpl.dwNumSampleLoops; i++) {\r\n        this.smpl.loops.push({\r\n          dwName: this.readUInt32(buffer),\r\n          dwType: this.readUInt32(buffer),\r\n          dwStart: this.readUInt32(buffer),\r\n          dwEnd: this.readUInt32(buffer),\r\n          dwFraction: this.readUInt32(buffer),\r\n          dwPlayCount: this.readUInt32(buffer),\r\n        });\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'data' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {boolean} samples True if the samples should be loaded.\r\n   * @throws {Error} If no 'data' chunk is found.\r\n   * @private\r\n   */\r\n  readDataChunk_(buffer, samples) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('data');\r\n    if (chunk) {\r\n      this.data.chunkId = 'data';\r\n      this.data.chunkSize = chunk.chunkSize;\r\n      if (samples) {\r\n        this.data.samples = buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end);\r\n      }\r\n    } else {\r\n      throw Error('Could not find the \"data\" chunk');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'bext' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readBextChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('bext');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.bext.chunkId = chunk.chunkId;\r\n      this.bext.chunkSize = chunk.chunkSize;\r\n      this.bext.description = this.readString(buffer, 256);\r\n      this.bext.originator = this.readString(buffer, 32);\r\n      this.bext.originatorReference = this.readString(buffer, 32);\r\n      this.bext.originationDate = this.readString(buffer, 10);\r\n      this.bext.originationTime = this.readString(buffer, 8);\r\n      this.bext.timeReference = [\r\n        this.readUInt32(buffer),\r\n        this.readUInt32(buffer)];\r\n      this.bext.version = this.readUInt16_(buffer);\r\n      this.bext.UMID = this.readString(buffer, 64);\r\n      this.bext.loudnessValue = this.readUInt16_(buffer);\r\n      this.bext.loudnessRange = this.readUInt16_(buffer);\r\n      this.bext.maxTruePeakLevel = this.readUInt16_(buffer);\r\n      this.bext.maxMomentaryLoudness = this.readUInt16_(buffer);\r\n      this.bext.maxShortTermLoudness = this.readUInt16_(buffer);\r\n      this.bext.reserved = this.readString(buffer, 180);\r\n      this.bext.codingHistory = this.readString(\r\n        buffer, this.bext.chunkSize - 602);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'iXML' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readiXMLChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('iXML');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.iXML.chunkId = chunk.chunkId;\r\n      this.iXML.chunkSize = chunk.chunkSize;\r\n      this.iXML.value = unpackString(\r\n        buffer, this.head, this.head + this.iXML.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'ds64' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @throws {Error} If no 'ds64' chunk is found and the file is RF64.\r\n   * @private\r\n   */\r\n  readDs64Chunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('ds64');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this.ds64.chunkId = chunk.chunkId;\r\n      this.ds64.chunkSize = chunk.chunkSize;\r\n      this.ds64.riffSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.riffSizeLow = this.readUInt32(buffer);\r\n      this.ds64.dataSizeHigh = this.readUInt32(buffer);\r\n      this.ds64.dataSizeLow = this.readUInt32(buffer);\r\n      this.ds64.originationTime = this.readUInt32(buffer);\r\n      this.ds64.sampleCountHigh = this.readUInt32(buffer);\r\n      this.ds64.sampleCountLow = this.readUInt32(buffer);\r\n      //if (wav.ds64.chunkSize > 28) {\r\n      //  wav.ds64.tableLength = unpack(\r\n      //    chunkData.slice(28, 32), uInt32_);\r\n      //  wav.ds64.table = chunkData.slice(\r\n      //     32, 32 + wav.ds64.tableLength);\r\n      //}\r\n    } else {\r\n      if (this.container == 'RF64') {\r\n        throw Error('Could not find the \"ds64\" chunk');\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the 'LIST' chunks of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let listChunks = this.findChunk('LIST', true);\r\n    if (listChunks !== null) {\r\n      for (let j=0; j < listChunks.length; j++) {\r\n        /** @type {!Object} */\r\n        let subChunk = listChunks[j];\r\n        this.LIST.push({\r\n          chunkId: subChunk.chunkId,\r\n          chunkSize: subChunk.chunkSize,\r\n          format: subChunk.format,\r\n          subChunks: []});\r\n        for (let x=0; x<subChunk.subChunks.length; x++) {\r\n          this.readLISTSubChunks_(subChunk.subChunks[x],\r\n            subChunk.format, buffer);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @param {string} format The 'LIST' format, 'adtl' or 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readLISTSubChunks_(subChunk, format, buffer) {\r\n    if (format == 'adtl') {\r\n      if (['labl', 'note','ltxt'].indexOf(subChunk.chunkId) > -1) {\r\n        this.readLISTadtlSubChunks_(buffer, subChunk);\r\n      }\r\n    // RIFF INFO tags like ICRD, ISFT, ICMT\r\n    } else if(format == 'INFO') {\r\n      this.readLISTINFOSubChunks_(buffer, subChunk);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'adtl'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTadtlSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    /** @type {!Object<string, string|number>} */\r\n    let item = {\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      dwName: this.readUInt32(buffer)\r\n    };\r\n    if (subChunk.chunkId == 'ltxt') {\r\n      item.dwSampleLength = this.readUInt32(buffer);\r\n      item.dwPurposeID = this.readUInt32(buffer);\r\n      item.dwCountry = this.readUInt16_(buffer);\r\n      item.dwLanguage = this.readUInt16_(buffer);\r\n      item.dwDialect = this.readUInt16_(buffer);\r\n      item.dwCodePage = this.readUInt16_(buffer);\r\n      item.value = ''; // kept for compatibility\r\n    } else {\r\n      item.value = this.readZSTR_(buffer, this.head);\r\n    }\r\n    this.LIST[this.LIST.length - 1].subChunks.push(item);\r\n  }\r\n\r\n  /**\r\n   * Read the sub chunks of a 'LIST' chunk of type 'INFO'.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @param {!Object} subChunk The 'LIST' subchunks.\r\n   * @private\r\n   */\r\n  readLISTINFOSubChunks_(buffer, subChunk) {\r\n    this.head = subChunk.chunkData.start;\r\n    this.LIST[this.LIST.length - 1].subChunks.push({\r\n      chunkId: subChunk.chunkId,\r\n      chunkSize: subChunk.chunkSize,\r\n      value: this.readZSTR_(buffer, this.head)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Read the 'junk' chunk of a wave file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  readJunkChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('junk');\r\n    if (chunk) {\r\n      this.junk = {\r\n        chunkId: chunk.chunkId,\r\n        chunkSize: chunk.chunkSize,\r\n        chunkData: [].slice.call(buffer.slice(\r\n          chunk.chunkData.start,\r\n          chunk.chunkData.end))\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read the '_PMX' chunk of a wav file.\r\n   * @param {!Uint8Array} buffer The wav file buffer.\r\n   * @private\r\n   */\r\n  read_PMXChunk_(buffer) {\r\n    /** @type {?Object} */\r\n    let chunk = this.findChunk('_PMX');\r\n    if (chunk) {\r\n      this.head = chunk.chunkData.start;\r\n      this._PMX.chunkId = chunk.chunkId;\r\n      this._PMX.chunkSize = chunk.chunkSize;\r\n      this._PMX.value = unpackString(\r\n        buffer, this.head, this.head + this._PMX.chunkSize);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a ZSTR string.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number=} [index=0] the index to start reading.\r\n   * @return {string} The string.\r\n   * @private\r\n   */\r\n  readZSTR_(bytes, index=0) {\r\n    for (let i = index; i < bytes.length; i++) {\r\n      this.head++;\r\n      if (bytes[i] === 0) {\r\n        break;\r\n      }\r\n    }\r\n    return unpackString(bytes, index, this.head - 1);\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @private\r\n   */\r\n  readUInt16_(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt16, this.head);\r\n    this.head += 2;\r\n    return value;\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}