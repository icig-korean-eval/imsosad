{"ast":null,"code":"/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\n\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\n\nimport { unpackString, unpack } from './parsers/binary';\n\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\nexport class RIFFFile {\n  constructor() {\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\n    this.container = '';\n    /**\r\n     * @type {number}\r\n     */\n    this.chunkSize = 0;\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\n    this.format = '';\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\n    this.signature = null;\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\n    this.head = 0;\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\n    this.uInt32 = {\n      bits: 32,\n      be: false\n    };\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\n    this.supported_containers = ['RIFF', 'RIFX'];\n  }\n\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\n  setSignature(buffer) {\n    this.head = 0;\n    this.container = this.readString(buffer, 4);\n    if (this.supported_containers.indexOf(this.container) === -1) {\n      throw Error('Not a supported format.');\n    }\n    this.uInt32.be = this.container === 'RIFX';\n    this.chunkSize = this.readUInt32(buffer);\n    this.format = this.readString(buffer, 4);\n    // The RIFF file signature\n    this.signature = {\n      chunkId: this.container,\n      chunkSize: this.chunkSize,\n      format: this.format,\n      subChunks: this.getSubChunksIndex_(buffer)\n    };\n  }\n\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\n  findChunk(chunkId, multiple = false) {\n    /** @type {!Array<Object>} */\n    let chunks = this.signature.subChunks;\n    /** @type {!Array<Object>} */\n    let chunk = [];\n    for (let i = 0; i < chunks.length; i++) {\n      if (chunks[i].chunkId == chunkId) {\n        if (multiple) {\n          chunk.push(chunks[i]);\n        } else {\n          return chunks[i];\n        }\n      }\n    }\n    if (chunkId == 'LIST') {\n      return chunk.length ? chunk : null;\n    }\n    return null;\n  }\n\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\n  readString(bytes, maxSize) {\n    /** @type {string} */\n    let str = '';\n    str = unpackString(bytes, this.head, this.head + maxSize);\n    this.head += maxSize;\n    return str;\n  }\n\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\n  readUInt32(bytes) {\n    /** @type {number} */\n    let value = unpack(bytes, this.uInt32, this.head);\n    this.head += 4;\n    return value;\n  }\n\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\n  getSubChunksIndex_(buffer) {\n    /** @type {!Array<!Object>} */\n    let chunks = [];\n    /** @type {number} */\n    let i = this.head;\n    while (i <= buffer.length - 8) {\n      chunks.push(this.getSubChunkIndex_(buffer, i));\n      i += 8 + chunks[chunks.length - 1].chunkSize;\n      i = i % 2 ? i + 1 : i;\n    }\n    return chunks;\n  }\n\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\n  getSubChunkIndex_(buffer, index) {\n    /** @type {!Object} */\n    let chunk = {\n      chunkId: this.getChunkId_(buffer, index),\n      chunkSize: this.getChunkSize_(buffer, index)\n    };\n    if (chunk.chunkId == 'LIST') {\n      chunk.format = unpackString(buffer, index + 8, index + 12);\n      this.head += 4;\n      chunk.subChunks = this.getSubChunksIndex_(buffer);\n    } else {\n      /** @type {number} */\n      let realChunkSize = chunk.chunkSize % 2 ? chunk.chunkSize + 1 : chunk.chunkSize;\n      this.head = index + 8 + realChunkSize;\n      chunk.chunkData = {\n        start: index + 8,\n        end: this.head\n      };\n    }\n    return chunk;\n  }\n\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\n  getChunkId_(buffer, index) {\n    this.head += 4;\n    return unpackString(buffer, index, index + 4);\n  }\n\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\n  getChunkSize_(buffer, index) {\n    this.head += 4;\n    return unpack(buffer, this.uInt32, index + 4);\n  }\n}","map":{"version":3,"names":["unpackString","unpack","RIFFFile","constructor","container","chunkSize","format","signature","head","uInt32","bits","be","supported_containers","setSignature","buffer","readString","indexOf","Error","readUInt32","chunkId","subChunks","getSubChunksIndex_","findChunk","multiple","chunks","chunk","i","length","push","bytes","maxSize","str","value","getSubChunkIndex_","index","getChunkId_","getChunkSize_","realChunkSize","chunkData","start","end"],"sources":["C:/Users/kimmi/Desktop/learning-interface/learning-interface/node_modules/wavefile/lib/riff-file.js"],"sourcesContent":["/*\r\n * Copyright (c) 2017-2019 Rafael da Silva Rocha.\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining\r\n * a copy of this software and associated documentation files (the\r\n * \"Software\"), to deal in the Software without restriction, including\r\n * without limitation the rights to use, copy, modify, merge, publish,\r\n * distribute, sublicense, and/or sell copies of the Software, and to\r\n * permit persons to whom the Software is furnished to do so, subject to\r\n * the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be\r\n * included in all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n *\r\n */\r\n\r\n/**\r\n * @fileoverview The RIFFFile class.\r\n * @see https://github.com/rochars/wavefile\r\n */\r\n\r\nimport { unpackString, unpack } from './parsers/binary';\r\n\r\n/**\r\n * A class to perform low-level reading of RIFF/RIFX files.\r\n */\r\nexport class RIFFFile {\r\n\r\n  constructor() {\r\n    /**\r\n     * The container identifier.\r\n     * 'RIFF', 'RIFX' and 'RF64' are supported.\r\n     * @type {string}\r\n     */\r\n    this.container = '';\r\n    /**\r\n     * @type {number}\r\n     */\r\n    this.chunkSize = 0;\r\n    /**\r\n     * The format.\r\n     * @type {string}\r\n     */\r\n    this.format = '';\r\n    /**\r\n     * A object defining the start and end of all chunks in a wav buffer.\r\n     * @type {Object}\r\n     */\r\n    this.signature = null;\r\n    /**\r\n     * @type {number}\r\n     * @protected\r\n     */\r\n    this.head = 0;\r\n    /**\r\n     * @type {!{bits: number, be: boolean}}\r\n     * @protected\r\n     */\r\n    this.uInt32 = {bits: 32, be: false};\r\n    /**\r\n     * The list of supported containers.\r\n     * Any format different from RIFX will be treated as RIFF.\r\n     * @type {!Array<string>}\r\n     * @protected\r\n     */\r\n    this.supported_containers = ['RIFF', 'RIFX'];\r\n  }\r\n\r\n  /**\r\n   * Read the signature of the chunks in a RIFF/RIFX file.\r\n   * @param {!Uint8Array} buffer The file bytes.\r\n   * @protected\r\n   */\r\n  setSignature(buffer) {\r\n    this.head = 0;\r\n    this.container = this.readString(buffer, 4);\r\n    if (this.supported_containers.indexOf(this.container) === -1) {\r\n      throw Error('Not a supported format.');\r\n    }\r\n    this.uInt32.be = this.container === 'RIFX';\r\n    this.chunkSize = this.readUInt32(buffer);\r\n    this.format = this.readString(buffer, 4);\r\n    // The RIFF file signature\r\n    this.signature = {\r\n      chunkId: this.container,\r\n      chunkSize: this.chunkSize,\r\n      format: this.format,\r\n      subChunks: this.getSubChunksIndex_(buffer)\r\n    };\r\n  }\r\n\r\n  /**\r\n    * Find a chunk by its fourCC_ in a array of RIFF chunks.\r\n    * @param {string} chunkId The chunk fourCC_.\r\n    * @param {boolean} [multiple=false] True if there may be multiple chunks\r\n    *    with the same chunkId.\r\n    * @return {Object}\r\n    * @protected\r\n    */\r\n  findChunk(chunkId, multiple=false) {\r\n    /** @type {!Array<Object>} */\r\n    let chunks = this.signature.subChunks;\r\n    /** @type {!Array<Object>} */\r\n    let chunk = [];\r\n    for (let i=0; i<chunks.length; i++) {\r\n      if (chunks[i].chunkId == chunkId) {\r\n        if (multiple) {\r\n          chunk.push(chunks[i]);\r\n        } else {\r\n          return chunks[i];\r\n        }\r\n      }\r\n    }\r\n    if (chunkId == 'LIST') {\r\n      return chunk.length ? chunk : null;\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Read bytes as a string from a RIFF chunk.\r\n   * @param {!Uint8Array} bytes The bytes.\r\n   * @param {number} maxSize the max size of the string.\r\n   * @return {string} The string.\r\n   * @protected\r\n   */\r\n  readString(bytes, maxSize) {\r\n    /** @type {string} */\r\n    let str = '';\r\n    str = unpackString(bytes, this.head, this.head + maxSize);\r\n    this.head += maxSize;\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Read a number from a chunk.\r\n   * @param {!Uint8Array} bytes The chunk bytes.\r\n   * @return {number} The number.\r\n   * @protected\r\n   */\r\n  readUInt32(bytes) {\r\n    /** @type {number} */\r\n    let value = unpack(bytes, this.uInt32, this.head);\r\n    this.head += 4;\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * Return the sub chunks of a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @return {!Array<Object>} The subchunks of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunksIndex_(buffer) {\r\n    /** @type {!Array<!Object>} */\r\n    let chunks = [];\r\n    /** @type {number} */\r\n    let i = this.head;\r\n    while(i <= buffer.length - 8) {\r\n      chunks.push(this.getSubChunkIndex_(buffer, i));\r\n      i += 8 + chunks[chunks.length - 1].chunkSize;\r\n      i = i % 2 ? i + 1 : i;\r\n    }\r\n    return chunks;\r\n  }\r\n\r\n  /**\r\n   * Return a sub chunk from a RIFF file.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {!Object} A subchunk of a RIFF/RIFX or LIST chunk.\r\n   * @private\r\n   */\r\n  getSubChunkIndex_(buffer, index) {\r\n    /** @type {!Object} */\r\n    let chunk = {\r\n      chunkId: this.getChunkId_(buffer, index),\r\n      chunkSize: this.getChunkSize_(buffer, index),\r\n    };\r\n    if (chunk.chunkId == 'LIST') {\r\n      chunk.format = unpackString(buffer, index + 8, index + 12);\r\n      this.head += 4;\r\n      chunk.subChunks = this.getSubChunksIndex_(buffer);\r\n    } else {\r\n      /** @type {number} */\r\n      let realChunkSize = chunk.chunkSize % 2 ?\r\n        chunk.chunkSize + 1 : chunk.chunkSize;\r\n      this.head = index + 8 + realChunkSize;\r\n      chunk.chunkData = {\r\n        start: index + 8,\r\n        end: this.head\r\n      };\r\n    }\r\n    return chunk;\r\n  }\r\n\r\n  /**\r\n   * Return the fourCC_ of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {string} The id of the chunk.\r\n   * @private\r\n   */\r\n  getChunkId_(buffer, index) {\r\n    this.head += 4;\r\n    return unpackString(buffer, index, index + 4);\r\n  }\r\n\r\n  /**\r\n   * Return the size of a chunk.\r\n   * @param {!Uint8Array} buffer the RIFF file bytes.\r\n   * @param {number} index The start index of the chunk.\r\n   * @return {number} The size of the chunk without the id and size fields.\r\n   * @private\r\n   */\r\n  getChunkSize_(buffer, index) {\r\n    this.head += 4;\r\n    return unpack(buffer, this.uInt32, index + 4);\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}